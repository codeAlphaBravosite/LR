<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>LogReel - Client-Side Video Logging</title>
    <style>
        /* CSS Reset (Minimal) */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: #e0e0e0;
            background-color: #1a1a1a; /* Dark background */
            overscroll-behavior-y: contain; /* Prevent pull-to-refresh on mobile */
        }

        body {
            display: flex;
            flex-direction: column;
        }

        #app {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }

        /* Theme Variables */
        :root {
            --primary-color: #007bff; /* A nice blue */
            --primary-hover: #0056b3;
            --secondary-color: #6c757d;
            --background-color: #1a1a1a;
            --surface-color: #2c2c2c; /* Cards, inputs */
            --text-color: #e0e0e0;
            --text-muted-color: #a0a0a0;
            --border-color: #444;
            --error-color: #dc3545;
            --success-color: #28a745;
            --star-color: #ffc107;
            --timeline-played-color: var(--primary-color);
            --timeline-buffered-color: #555;
            --timeline-mark-color: var(--star-color);
        }

        /* General Styles */
        h1, h2, h3 {
            margin-bottom: 0.75em;
            color: var(--text-color);
        }

        button, input[type="text"], textarea {
            font-family: inherit;
            font-size: 1rem;
            padding: 0.6em 1em;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--surface-color);
            color: var(--text-color);
        }

        button {
            cursor: pointer;
            background-color: var(--primary-color);
            color: white;
            border: none;
            transition: background-color 0.2s ease;
        }
        button:hover:not(:disabled) {
            background-color: var(--primary-hover);
        }
        button:disabled {
            background-color: var(--secondary-color);
            cursor: not-allowed;
            opacity: 0.7;
        }
        button.secondary {
            background-color: var(--secondary-color);
        }
        button.secondary:hover:not(:disabled) {
            background-color: #5a6268;
        }
        button.danger {
            background-color: var(--error-color);
        }
        button.danger:hover:not(:disabled) {
            background-color: #c82333;
        }
        .icon-button {
            background: none;
            border: none;
            color: var(--text-muted-color);
            padding: 0.5em;
            font-size: 1.2rem;
        }
        .icon-button:hover {
            color: var(--primary-color);
        }


        input[type="text"], textarea {
            width: 100%;
            margin-bottom: 0.5em;
        }
        textarea {
            min-height: 80px;
            resize: vertical;
        }

        .screen {
            padding: 1.5em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Allow content to scroll */
        }
        .screen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5em;
            padding-bottom: 0.5em;
            border-bottom: 1px solid var(--border-color);
        }
        .screen-header h1, .screen-header h2 {
            margin-bottom: 0;
            font-size: 1.5rem;
        }
        .back-button {
            font-size: 1rem;
            padding: 0.5em 0.8em;
        }

        .empty-state {
            text-align: center;
            color: var(--text-muted-color);
            padding: 2em;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            margin-top: 2em;
        }
        .empty-state p { margin-bottom: 1em; }

        /* Project Dashboard (Screen A) */
        #project-list {
            list-style: none;
            padding: 0;
        }
        .project-item {
            background-color: var(--surface-color);
            padding: 1em 1.5em;
            margin-bottom: 1em;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .project-item:hover {
            background-color: #3a3a3a;
        }
        .project-item-info h3 {
            margin-bottom: 0.25em;
            font-size: 1.2rem;
        }
        .project-item-info span {
            font-size: 0.9rem;
            color: var(--text-muted-color);
        }
        .project-item-actions button {
            margin-left: 0.5em;
            padding: 0.4em 0.6em; /* Smaller delete button */
            font-size: 0.9rem;
        }

        /* Assembly Hub (Screen B) */
        #assembly-hub-screen .search-bar {
            width: 100%;
            margin-bottom: 1.5em;
        }
        #video-list {
            display: grid;
            gap: 1.5em;
            grid-template-columns: 1fr; /* Mobile first */
        }
        @media (min-width: 768px) { /* Tablet and up */
            #video-list {
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            }
        }

        .video-card {
            background-color: var(--surface-color);
            border-radius: 8px;
            padding: 1em;
            display: flex;
            flex-direction: column;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .video-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* Align star to top */
            margin-bottom: 0.75em;
        }
        .video-card-header h4 {
            font-size: 1.1rem;
            word-break: break-all; /* Prevent long filenames from breaking layout */
            margin-right: 0.5em; /* Space for star */
            flex-grow: 1;
        }
        .video-card-header .video-number {
            color: var(--text-muted-color);
            font-weight: bold;
            margin-right: 0.5em;
        }
        .star-toggle {
            font-size: 1.5rem; /* Larger star */
            color: var(--text-muted-color);
            cursor: pointer;
        }
        .star-toggle.important {
            color: var(--star-color);
        }
        .video-thumbnail-placeholder {
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
            background-color: #444;
            border-radius: 4px;
            margin-bottom: 0.75em;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted-color);
        }
        .video-card-meta {
            font-size: 0.9rem;
            color: var(--text-muted-color);
            margin-bottom: 1em;
        }
        .video-card-actions {
            display: flex;
            gap: 0.5em; /* Space between buttons */
            margin-top: auto; /* Push actions to bottom */
        }
        .video-card-actions button {
            flex-grow: 1;
        }
        .video-card-logs-summary {
            font-size: 0.9rem;
            color: var(--text-muted-color);
            margin-top: 0.5em;
            max-height: 100px; /* Limit height */
            overflow-y: auto;
            border-top: 1px solid var(--border-color);
            padding-top: 0.5em;
        }
        .video-card-logs-summary p { margin-bottom: 0.3em; }

        /* Logging Station (Screen C) */
        #logging-station-screen {
            display: flex;
            flex-direction: column;
        }
        .video-player-area {
            background-color: #000;
            margin-bottom: 1em;
            position: sticky; /* Sticky player on scroll for larger screens */
            top: 0;
            z-index: 10;
        }
        #video-player {
            width: 100%;
            max-height: 60vh; /* Limit player height */
            display: block; /* Remove extra space below video */
        }
        .video-timeline-container {
            position: relative;
            height: 10px;
            background-color: #333;
            cursor: pointer;
            margin: 0.5em 0;
        }
        .timeline-progress, .timeline-mark-in-out {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
        }
        .timeline-progress {
            background-color: var(--timeline-played-color);
            z-index: 2;
        }
        .timeline-mark-in-out {
            background-color: var(--timeline-mark-color);
            opacity: 0.5;
            z-index: 1;
        }

        .logging-controls {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            gap: 1em;
            margin-bottom: 1.5em;
            align-items: center;
        }
        .logging-controls button { padding: 0.8em 1.2em; }
        .mark-time { font-size: 0.8em; color: var(--text-muted-color); display: block; }

        .log-form {
            background-color: var(--surface-color);
            padding: 1.5em;
            border-radius: 8px;
            margin-bottom: 1.5em;
        }
        .star-rating {
            display: flex;
            margin-bottom: 1em;
        }
        .star-rating .star {
            font-size: 1.8rem;
            color: var(--text-muted-color);
            cursor: pointer;
            margin-right: 0.25em;
        }
        .star-rating .star.selected, .star-rating .star:hover {
            color: var(--star-color);
        }
        .keywords-input-area { margin-bottom: 1em; }
        .keywords-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5em;
            margin-top: 0.5em;
            padding: 0.5em;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            min-height: 30px;
        }
        .keyword-tag {
            background-color: var(--primary-color);
            color: white;
            padding: 0.3em 0.6em;
            border-radius: 4px;
            font-size: 0.9em;
            display: flex;
            align-items: center;
        }
        .keyword-tag .remove-keyword {
            margin-left: 0.5em;
            cursor: pointer;
            font-weight: bold;
        }

        .saved-logs-list {
            flex-grow: 1; /* Take remaining space */
            overflow-y: auto; /* Scroll for logs */
        }
        .log-item {
            background-color: var(--surface-color);
            padding: 1em;
            margin-bottom: 1em;
            border-radius: 8px;
            border-left: 4px solid var(--primary-color);
        }
        .log-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5em;
        }
        .log-item-time { font-weight: bold; color: var(--text-color); }
        .log-item-rating { color: var(--star-color); }
        .log-item-notes { margin-bottom: 0.5em; white-space: pre-wrap; word-wrap: break-word; }
        .log-item-keywords .keyword-tag {
            background-color: var(--secondary-color); /* Different color for display */
            margin-right: 0.3em;
            margin-bottom: 0.3em;
            display: inline-flex; /* Fit tags in line */
        }
        .log-item-actions { margin-top: 0.75em; display: flex; gap: 0.5em; justify-content: flex-end; }


        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1em;
        }
        .modal-content {
            background-color: var(--surface-color);
            padding: 2em;
            border-radius: 8px;
            max-width: 90vw;
            width: 500px; /* Default width */
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1em;
        }
        .modal-header h3 { margin-bottom: 0; }
        .close-modal-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-muted-color);
            cursor: pointer;
        }
        .modal-actions { margin-top: 1.5em; display: flex; justify-content: flex-end; gap: 0.5em; }

        #preview-selects-player { width: 100%; margin-bottom: 1em; }
        #preview-selects-info { text-align: center; margin-bottom: 1em; color: var(--text-muted-color); }
        #preview-selects-notes {
            background-color: #333;
            padding: 0.5em;
            border-radius: 4px;
            min-height: 50px;
            margin-bottom: 1em;
            font-size: 0.9em;
            white-space: pre-wrap;
        }

        /* Notifications */
        #notifications-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .notification {
            padding: 1em 1.5em;
            border-radius: 6px;
            color: white;
            min-width: 250px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateX(100%);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        .notification.info { background-color: var(--primary-color); }
        .notification.success { background-color: var(--success-color); }
        .notification.error { background-color: var(--error-color); }

        /* Utility classes */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .mt-1 { margin-top: 1em; }
        .mb-1 { margin-bottom: 1em; }
        .button-group { display: flex; gap: 0.5em; }

    </style>
</head>
<body>
    <div id="app">
        <!-- Screen A: Project Dashboard -->
        <section id="project-dashboard-screen" class="screen">
            <div class="screen-header">
                <h1>LogReel</h1>
                <button id="export-all-data-btn" class="secondary">Export All Data</button>
            </div>
            <button id="create-new-project-btn" class="mb-1">Create New Project</button>
            <ul id="project-list">
                <!-- Project items will be dynamically inserted here -->
            </ul>
            <div id="project-dashboard-empty-state" class="empty-state hidden">
                <p>No projects yet.</p>
                <p>Click "Create New Project" to get started!</p>
            </div>
        </section>

        <!-- Screen B: Assembly Hub (Project View) -->
        <section id="assembly-hub-screen" class="screen hidden">
            <div class="screen-header">
                <button id="assembly-back-to-dashboard-btn" class="back-button">< Projects</button>
                <h2 id="assembly-project-title">Project Name</h2>
            </div>
            <input type="text" id="assembly-search-bar" class="search-bar" placeholder="Search videos or logs (filename, notes, keywords)...">
            <div class="button-group mb-1">
                <button id="add-videos-btn">Add Video(s)</button>
                <input type="file" id="video-file-input" multiple accept="video/*" class="hidden">
            </div>
            <div id="video-list">
                <!-- Video cards will be dynamically inserted here -->
            </div>
            <div id="assembly-hub-empty-state" class="empty-state hidden">
                <p>No videos in this project yet.</p>
                <p>Click "Add Video(s)" to import your footage.</p>
            </div>
        </section>

        <!-- Screen C: Logging Station (Individual Video View) -->
        <section id="logging-station-screen" class="screen hidden">
            <div class="screen-header">
                <button id="logging-back-to-assembly-btn" class="back-button">< Project Videos</button>
                <h2 id="logging-video-filename">Video Filename.mp4</h2>
            </div>

            <div class="video-player-area">
                <video id="video-player" controls></video>
                <div class="video-timeline-container" id="video-timeline-container">
                    <div class="timeline-mark-in-out" id="timeline-mark-in-out"></div>
                    <div class="timeline-progress" id="timeline-progress"></div>
                </div>
                <div class="button-group" style="justify-content: space-around; padding: 0.5em 0;">
                    <label for="playback-speed">Speed:</label>
                    <select id="playback-speed">
                        <option value="0.25">0.25x</option>
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1" selected>1x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                    </select>
                </div>
            </div>

            <div class="logging-controls">
                <button id="mark-in-btn">Mark In <span class="mark-time" id="mark-in-time-display">00:00:00</span></button>
                <button id="mark-out-btn">Mark Out <span class="mark-time" id="mark-out-time-display">00:00:00</span></button>
            </div>

            <div class="log-form">
                <h3>Create New Log</h3>
                <label for="log-notes">Notes:</label>
                <textarea id="log-notes" placeholder="Enter notes for this segment..."></textarea>
                
                <label>Rating:</label>
                <div class="star-rating" id="log-rating">
                    <span class="star" data-value="1">☆</span>
                    <span class="star" data-value="2">☆</span>
                    <span class="star" data-value="3">☆</span>
                    <span class="star" data-value="4">☆</span>
                    <span class="star" data-value="5">☆</span>
                </div>
                
                <label for="log-keywords-input">Keywords (press Enter to add):</label>
                <div class="keywords-input-area">
                    <input type="text" id="log-keywords-input" placeholder="e.g., b-roll, interview, good take">
                    <div class="keywords-container" id="log-keywords-container">
                        <!-- Keyword tags will appear here -->
                    </div>
                </div>
                <button id="save-log-btn">Save Log</button>
            </div>

            <h3>Saved Logs</h3>
            <div id="saved-logs-list" class="saved-logs-list">
                <!-- Log items will be dynamically inserted here -->
            </div>
            <div id="logging-station-empty-state" class="empty-state hidden">
                <p>No logs created for this video yet.</p>
                <p>Use the controls above to mark segments and save your logs.</p>
            </div>
        </section>

        <!-- Modals -->
        <div id="preview-selects-modal" class="modal hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Preview Selects</h3>
                    <button class="close-modal-btn" data-target-modal="preview-selects-modal">×</button>
                </div>
                <video id="preview-selects-player" controls></video>
                <div id="preview-selects-info">Playing Select X of Y</div>
                <div id="preview-selects-notes-label">Current Select Notes:</div>
                <div id="preview-selects-notes"></div>
                <div class="modal-actions">
                    <button class="secondary close-modal-btn" data-target-modal="preview-selects-modal">Close</button>
                </div>
            </div>
        </div>

        <div id="confirm-dialog" class="modal hidden">
            <div class="modal-content">
                <h3 id="confirm-dialog-title">Confirm Action</h3>
                <p id="confirm-dialog-message">Are you sure?</p>
                <div class="modal-actions">
                    <button id="confirm-dialog-cancel-btn" class="secondary">Cancel</button>
                    <button id="confirm-dialog-confirm-btn" class="danger">Confirm</button>
                </div>
            </div>
        </div>

        <div id="notifications-container"></div>
    </div>

<script>
(function() {
    'use strict';

    // --- App State ---
    const state = {
        currentScreen: 'project-dashboard',
        currentProjectId: null,
        currentProjectName: '',
        currentVideoId: null,
        currentVideoFile: null, // Actual File object for current video
        currentVideoFilename: '',
        currentVideoDuration: 0,
        currentMarkIn: null,
        currentMarkOut: null,
        currentLogRating: 0,
        currentLogKeywords: [],
        tempFileCache: {} // To store File objects temporarily by generated ID if not putting in IDB
    };

    // --- DOM Elements Cache ---
    const DOMElements = {};

    // --- Database (IndexedDB) ---
    const DB_NAME = 'LogReelDB';
    const DB_VERSION = 1;
    const STORE_PROJECTS = 'projects';
    const STORE_VIDEOS = 'videos';
    const STORE_LOGS = 'logs';
    let db;

    async function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onerror = (event) => {
                console.error("Database error:", event.target.error);
                reject("Database error: " + event.target.error);
            };

            request.onupgradeneeded = (event) => {
                db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_PROJECTS)) {
                    db.createObjectStore(STORE_PROJECTS, { keyPath: 'id', autoIncrement: true });
                }
                if (!db.objectStoreNames.contains(STORE_VIDEOS)) {
                    const videoStore = db.createObjectStore(STORE_VIDEOS, { keyPath: 'id', autoIncrement: true });
                    videoStore.createIndex('projectId', 'projectId', { unique: false });
                }
                if (!db.objectStoreNames.contains(STORE_LOGS)) {
                    const logStore = db.createObjectStore(STORE_LOGS, { keyPath: 'id', autoIncrement: true });
                    logStore.createIndex('videoId', 'videoId', { unique: false });
                    logStore.createIndex('projectId', 'projectId', { unique: false });
                }
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                resolve(db);
            };
        });
    }

    async function dbAdd(storeName, item) {
        return new Promise((resolve, reject) => {
            if (!db) return reject("DB not initialized");
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.add(item);
            request.onsuccess = (event) => resolve(event.target.result); // Returns the new key
            request.onerror = (event) => reject("Error adding item: " + event.target.error);
        });
    }

    async function dbGetAll(storeName) {
        return new Promise((resolve, reject) => {
            if (!db) return reject("DB not initialized");
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result);
            request.onerror = (event) => reject("Error getting all items: " + event.target.error);
        });
    }
    
    async function dbGetById(storeName, id) {
        return new Promise((resolve, reject) => {
            if (!db) return reject("DB not initialized");
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get(id);
            request.onsuccess = () => resolve(request.result);
            request.onerror = (event) => reject("Error getting item by ID: " + event.target.error);
        });
    }

    async function dbGetByIndex(storeName, indexName, query) {
        return new Promise((resolve, reject) => {
            if (!db) return reject("DB not initialized");
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const index = store.index(indexName);
            const request = index.getAll(query);
            request.onsuccess = () => resolve(request.result);
            request.onerror = (event) => reject("Error getting items by index: " + event.target.error);
        });
    }

    async function dbUpdate(storeName, item) {
        return new Promise((resolve, reject) => {
            if (!db) return reject("DB not initialized");
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.put(item); // put = update if key exists, else add
            request.onsuccess = () => resolve(request.result);
            request.onerror = (event) => reject("Error updating item: " + event.target.error);
        });
    }

    async function dbDelete(storeName, key) {
        return new Promise((resolve, reject) => {
            if (!db) return reject("DB not initialized");
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.delete(key);
            request.onsuccess = () => resolve();
            request.onerror = (event) => reject("Error deleting item: " + event.target.error);
        });
    }

    // --- Router ---
    function navigateTo(screenId, params = {}) {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        DOMElements[screenId + 'Screen'].classList.remove('hidden');
        state.currentScreen = screenId;

        window.scrollTo(0, 0); // Scroll to top on navigation

        // Handle specific screen initializations
        if (screenId === 'project-dashboard') {
            loadAndRenderProjects();
        } else if (screenId === 'assembly-hub') {
            state.currentProjectId = params.projectId;
            state.currentProjectName = params.projectName;
            DOMElements.assemblyProjectTitle.textContent = state.currentProjectName;
            loadAndRenderVideosForProject(state.currentProjectId);
        } else if (screenId === 'logging-station') {
            state.currentVideoId = params.videoId;
            state.currentVideoFilename = params.videoFilename;
            state.currentVideoFile = params.videoFile; // Pass the File object
            DOMElements.loggingVideoFilename.textContent = state.currentVideoFilename;
            setupLoggingStation();
        }
    }

    // --- Utility Functions ---
    function formatTime(totalSeconds, showMilliseconds = false) {
        if (isNaN(totalSeconds) || totalSeconds < 0) return "00:00:00";
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = Math.floor(totalSeconds % 60);
        const milliseconds = Math.floor((totalSeconds - Math.floor(totalSeconds)) * 1000);

        let timeStr = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        if (showMilliseconds) {
            timeStr += `.${String(milliseconds).padStart(3, '0')}`;
        }
        return timeStr;
    }

    function showNotification(message, type = 'info', duration = 3000) {
        const container = DOMElements.notificationsContainer;
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;
        
        container.appendChild(notification);
        // Trigger reflow for transition
        void notification.offsetWidth; 
        notification.classList.add('show');

        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => {
                if (container.contains(notification)) {
                     container.removeChild(notification);
                }
            }, 300); // Wait for transition to finish
        }, duration);
    }

    function showConfirmDialog(title, message, onConfirm) {
        DOMElements.confirmDialogTitle.textContent = title;
        DOMElements.confirmDialogMessage.textContent = message;
        DOMElements.confirmDialog.classList.remove('hidden');

        return new Promise((resolve) => {
            DOMElements.confirmDialogConfirmBtn.onclick = () => {
                DOMElements.confirmDialog.classList.add('hidden');
                if (onConfirm) onConfirm();
                resolve(true);
            };
            DOMElements.confirmDialogCancelBtn.onclick = () => {
                DOMElements.confirmDialog.classList.add('hidden');
                resolve(false);
            };
        });
    }
    
    function sanitizeHTML(str) {
        const temp = document.createElement('div');
        temp.textContent = str;
        return temp.innerHTML;
    }


    // --- Project Dashboard (Screen A) ---
    async function loadAndRenderProjects() {
        try {
            const projects = await dbGetAll(STORE_PROJECTS);
            DOMElements.projectList.innerHTML = ''; // Clear existing list
            if (projects.length === 0) {
                DOMElements.projectDashboardEmptyState.classList.remove('hidden');
            } else {
                DOMElements.projectDashboardEmptyState.classList.add('hidden');
                for (const project of projects) {
                    const videosInProject = await dbGetByIndex(STORE_VIDEOS, 'projectId', project.id);
                    const videoCount = videosInProject.length;

                    const li = document.createElement('li');
                    li.className = 'project-item';
                    li.dataset.projectId = project.id;
                    li.dataset.projectName = project.name;
                    li.innerHTML = `
                        <div class="project-item-info">
                            <h3>${sanitizeHTML(project.name)}</h3>
                            <span>${videoCount} video(s)</span>
                        </div>
                        <div class="project-item-actions">
                            <button class="danger delete-project-btn" data-project-id="${project.id}">Delete</button>
                        </div>
                    `;
                    li.querySelector('.project-item-info').addEventListener('click', () => {
                        navigateTo('assembly-hub', { projectId: project.id, projectName: project.name });
                    });
                    DOMElements.projectList.appendChild(li);
                }
            }
        } catch (error) {
            console.error("Error loading projects:", error);
            showNotification("Failed to load projects.", "error");
        }
    }

    async function handleCreateNewProject() {
        const projectName = prompt("Enter project name:");
        if (projectName && projectName.trim() !== "") {
            try {
                await dbAdd(STORE_PROJECTS, { name: projectName.trim(), createdAt: new Date() });
                showNotification(`Project "${projectName.trim()}" created.`, "success");
                loadAndRenderProjects();
            } catch (error) {
                console.error("Error creating project:", error);
                showNotification("Failed to create project.", "error");
            }
        }
    }

    async function handleDeleteProject(projectId) {
        const project = await dbGetById(STORE_PROJECTS, projectId);
        if (!project) return;

        const confirmed = await showConfirmDialog(
            "Delete Project",
            `Are you sure you want to delete project "${sanitizeHTML(project.name)}" and all its videos and logs? This action cannot be undone.`,
            null
        );

        if (confirmed) {
            try {
                // Delete logs for this project
                const logs = await dbGetByIndex(STORE_LOGS, 'projectId', projectId);
                for (const log of logs) {
                    await dbDelete(STORE_LOGS, log.id);
                }
                // Delete videos for this project
                const videos = await dbGetByIndex(STORE_VIDEOS, 'projectId', projectId);
                for (const video of videos) {
                    await dbDelete(STORE_VIDEOS, video.id);
                }
                // Delete project
                await dbDelete(STORE_PROJECTS, projectId);
                showNotification(`Project "${sanitizeHTML(project.name)}" deleted.`, "success");
                loadAndRenderProjects();
            } catch (error) {
                console.error("Error deleting project:", error);
                showNotification("Failed to delete project.", "error");
            }
        }
    }

    // --- Assembly Hub (Screen B) ---
    async function loadAndRenderVideosForProject(projectId, searchTerm = '') {
        try {
            let videos = await dbGetByIndex(STORE_VIDEOS, 'projectId', projectId);
            DOMElements.videoList.innerHTML = '';

            if (searchTerm) {
                searchTerm = searchTerm.toLowerCase();
                const videoIdsWithMatchingLogs = new Set();
                const allLogsForProject = await dbGetByIndex(STORE_LOGS, 'projectId', projectId);
                
                for (const log of allLogsForProject) {
                    if ( (log.notes && log.notes.toLowerCase().includes(searchTerm)) ||
                         (log.keywords && log.keywords.some(k => k.toLowerCase().includes(searchTerm))) ) {
                        videoIdsWithMatchingLogs.add(log.videoId);
                    }
                }

                videos = videos.filter(video => 
                    video.filename.toLowerCase().includes(searchTerm) || videoIdsWithMatchingLogs.has(video.id)
                );
            }
            
            videos.sort((a,b) => new Date(a.createdAt) - new Date(b.createdAt));


            if (videos.length === 0 && !searchTerm) {
                DOMElements.assemblyHubEmptyState.classList.remove('hidden');
            } else {
                DOMElements.assemblyHubEmptyState.classList.add('hidden');
            }

            if (videos.length === 0 && searchTerm) {
                 DOMElements.videoList.innerHTML = `<p class="text-muted-color text-center">No videos match your search criteria.</p>`;
            }

            videos.forEach(async (video, index) => {
                const logs = await dbGetByIndex(STORE_LOGS, 'videoId', video.id);
                const logCount = logs.length;

                const card = document.createElement('div');
                card.className = 'video-card';
                card.dataset.videoId = video.id;
                card.innerHTML = `
                    <div class="video-card-header">
                        <span class="video-number">${index + 1}.</span>
                        <h4>${sanitizeHTML(video.filename)}</h4>
                        <span class="star-toggle ${video.isImportant ? 'important' : ''}" data-video-id="${video.id}">★</span>
                    </div>
                    <div class="video-thumbnail-placeholder">
                        <span>Video Preview</span>
                    </div>
                    <div class="video-card-meta">
                        <span>${logCount} log(s)</span>
                    </div>
                    <div class="video-card-actions">
                        <button class="log-video-btn">Log Video</button>
                        <button class="preview-selects-btn" ${logCount === 0 ? 'disabled' : ''}>Preview Selects</button>
                    </div>
                    <button class="secondary view-video-logs-btn mt-1">View Logs (${logCount})</button>
                    <div class="video-card-logs-summary hidden">
                        <!-- Summarized logs will go here -->
                    </div>
                    <button class="danger delete-video-btn mt-1">Delete Video</button>
                `;

                card.querySelector('.log-video-btn').addEventListener('click', () => {
                    // Critical: Retrieve the File object to pass it
                    const videoFile = video.fileObject; // Assuming fileObject is stored
                    if (!videoFile && state.tempFileCache[video.id]) { // Fallback if not directly in video obj
                        video.fileObject = state.tempFileCache[video.id];
                    }
                    if (!video.fileObject) {
                        showNotification("Video file data not found. Please re-add the video.", "error");
                        // Ideally, prompt to re-select the file using its stored name.
                        // For now, simple error.
                        return;
                    }
                    navigateTo('logging-station', { 
                        videoId: video.id, 
                        videoFilename: video.filename,
                        videoFile: video.fileObject // Pass the File object
                    });
                });
                
                card.querySelector('.star-toggle').addEventListener('click', () => toggleVideoImportant(video.id));
                card.querySelector('.preview-selects-btn').addEventListener('click', () => handlePreviewSelects(video.id));
                card.querySelector('.view-video-logs-btn').addEventListener('click', (e) => toggleLogsSummary(video.id, e.target));
                card.querySelector('.delete-video-btn').addEventListener('click', () => handleDeleteVideo(video.id, projectId));


                DOMElements.videoList.appendChild(card);
            });

        } catch (error) {
            console.error("Error loading videos for project:", error);
            showNotification("Failed to load videos.", "error");
        }
    }
    
    async function toggleLogsSummary(videoId, button) {
        const card = button.closest('.video-card');
        const summaryDiv = card.querySelector('.video-card-logs-summary');
        const isHidden = summaryDiv.classList.contains('hidden');

        if (isHidden) {
            // Load and display logs
            const logs = await dbGetByIndex(STORE_LOGS, 'videoId', videoId);
            logs.sort((a,b) => a.inTime - b.inTime);
            summaryDiv.innerHTML = logs.length > 0 ? '' : '<p>No logs for this video.</p>';
            logs.forEach(log => {
                const logEntry = document.createElement('p');
                logEntry.textContent = `[${formatTime(log.inTime)} - ${formatTime(log.outTime)}] ${sanitizeHTML(log.notes.substring(0,50))}${log.notes.length > 50 ? '...' : ''}`;
                summaryDiv.appendChild(logEntry);
            });
            summaryDiv.classList.remove('hidden');
            button.textContent = `Hide Logs`;
        } else {
            summaryDiv.classList.add('hidden');
            button.textContent = `View Logs (${summaryDiv.parentElement.querySelector('.video-card-meta span').textContent.split(' ')[0]})`; // Update count if needed
        }
    }

    async function handleAddVideos() {
        DOMElements.videoFileInput.click(); // Trigger file input
    }

    async function processSelectedVideoFiles(files) {
        if (!state.currentProjectId) {
            showNotification("No project selected.", "error");
            return;
        }
        let filesAddedCount = 0;
        for (const file of files) {
            if (file.type.startsWith('video/')) {
                try {
                    // Store the File object directly. Most modern browsers support this.
                    const videoData = {
                        projectId: state.currentProjectId,
                        filename: file.name,
                        fileObject: file, // Store the actual File object
                        isImportant: false,
                        createdAt: new Date()
                    };
                    const newVideoId = await dbAdd(STORE_VIDEOS, videoData);
                    // For safety, if fileObject isn't reliably stored by IDB or is too large,
                    // keep it in a temporary cache for the session.
                    // state.tempFileCache[newVideoId] = file; 

                    filesAddedCount++;
                } catch (error) {
                    console.error("Error adding video:", file.name, error);
                    showNotification(`Failed to add video: ${file.name}. Storage might be full or file too large.`, "error");
                }
            } else {
                showNotification(`File ${file.name} is not a valid video format.`, "error");
            }
        }
        if (filesAddedCount > 0) {
            showNotification(`${filesAddedCount} video(s) added successfully.`, "success");
            loadAndRenderVideosForProject(state.currentProjectId);
        }
    }

    async function toggleVideoImportant(videoId) {
        try {
            const video = await dbGetById(STORE_VIDEOS, videoId);
            if (video) {
                video.isImportant = !video.isImportant;
                await dbUpdate(STORE_VIDEOS, video);
                // Update UI directly for responsiveness
                const starToggle = DOMElements.videoList.querySelector(`.star-toggle[data-video-id="${videoId}"]`);
                if (starToggle) {
                    starToggle.classList.toggle('important', video.isImportant);
                }
            }
        } catch (error) {
            console.error("Error toggling video importance:", error);
            showNotification("Failed to update video importance.", "error");
        }
    }

    async function handleDeleteVideo(videoId, projectId) {
        const video = await dbGetById(STORE_VIDEOS, videoId);
        if (!video) return;

        const confirmed = await showConfirmDialog(
            "Delete Video",
            `Are you sure you want to delete video "${sanitizeHTML(video.filename)}" and all its logs? This action cannot be undone.`,
            null
        );

        if (confirmed) {
            try {
                // Delete logs for this video
                const logs = await dbGetByIndex(STORE_LOGS, 'videoId', videoId);
                for (const log of logs) {
                    await dbDelete(STORE_LOGS, log.id);
                }
                // Delete video
                await dbDelete(STORE_VIDEOS, videoId);
                showNotification(`Video "${sanitizeHTML(video.filename)}" deleted.`, "success");
                loadAndRenderVideosForProject(projectId); // Reload videos for the current project
            } catch (error) {
                console.error("Error deleting video:", error);
                showNotification("Failed to delete video.", "error");
            }
        }
    }
    
    function handleAssemblySearch(event) {
        const searchTerm = event.target.value;
        loadAndRenderVideosForProject(state.currentProjectId, searchTerm);
    }


    // --- Logging Station (Screen C) ---
    let logVideoPlayer; // Keep reference to player
    let currentLogKeywords = []; // For the form

    async function setupLoggingStation() {
        logVideoPlayer = DOMElements.videoPlayer;
        resetLogForm();
        loadLogsForCurrentVideo();

        if (state.currentVideoFile && state.currentVideoFile instanceof File) {
            try {
                // Revoke previous object URL if any to prevent memory leaks
                if (logVideoPlayer.src && logVideoPlayer.src.startsWith('blob:')) {
                    URL.revokeObjectURL(logVideoPlayer.src);
                }
                logVideoPlayer.src = URL.createObjectURL(state.currentVideoFile);
                logVideoPlayer.onloadedmetadata = () => {
                    state.currentVideoDuration = logVideoPlayer.duration;
                    updateMarkInOutDisplays(); // Update with 00:00:00 initially
                };
                logVideoPlayer.ontimeupdate = handleVideoTimeUpdate;
                logVideoPlayer.onseeked = handleVideoTimeUpdate; // Update displays after seeking
                
                DOMElements.timelineMarkInOut.style.width = '0%';
                DOMElements.timelineMarkInOut.style.left = '0%';

            } catch (error) {
                console.error("Error setting up video player:", error);
                showNotification("Could not load video. The file might be corrupted or in an unsupported format.", "error");
                navigateTo('assembly-hub', { projectId: state.currentProjectId, projectName: state.currentProjectName }); // Go back
            }
        } else {
            showNotification("Video file not available. Please re-select the video.", "error");
            // Potentially attempt to retrieve from DB if not passed directly, but fileObject should be passed.
            // For now, assume state.currentVideoFile is populated correctly by navigateTo
             const videoData = await dbGetById(STORE_VIDEOS, state.currentVideoId);
             if (videoData && videoData.fileObject) {
                 state.currentVideoFile = videoData.fileObject;
                 setupLoggingStation(); // Retry
             } else {
                navigateTo('assembly-hub', { projectId: state.currentProjectId, projectName: state.currentProjectName });
             }
        }
        DOMElements.playbackSpeed.value = logVideoPlayer.playbackRate;
    }

    function handleVideoTimeUpdate() {
        if (!logVideoPlayer || isNaN(logVideoPlayer.currentTime) || isNaN(state.currentVideoDuration) || state.currentVideoDuration === 0) return;
        
        const currentTime = logVideoPlayer.currentTime;
        const progressPercent = (currentTime / state.currentVideoDuration) * 100;
        DOMElements.timelineProgress.style.width = `${progressPercent}%`;

        updateMarkInOutDisplays(currentTime);
    }
    
    function updateMarkInOutDisplays(currentTime) {
        if (currentTime === undefined && logVideoPlayer) currentTime = logVideoPlayer.currentTime;
        if (currentTime === undefined) currentTime = 0; // Default if player not ready

        DOMElements.markInTimeDisplay.textContent = state.currentMarkIn !== null ? formatTime(state.currentMarkIn, true) : formatTime(currentTime, true);
        DOMElements.markOutTimeDisplay.textContent = state.currentMarkOut !== null ? formatTime(state.currentMarkOut, true) : formatTime(currentTime, true);
        
        // Update visual representation of Mark In/Out on timeline
        if (state.currentMarkIn !== null && state.currentMarkOut !== null && state.currentMarkOut > state.currentMarkIn && state.currentVideoDuration > 0) {
            const inPercent = (state.currentMarkIn / state.currentVideoDuration) * 100;
            const outPercent = (state.currentMarkOut / state.currentVideoDuration) * 100;
            DOMElements.timelineMarkInOut.style.left = `${inPercent}%`;
            DOMElements.timelineMarkInOut.style.width = `${outPercent - inPercent}%`;
        } else if (state.currentMarkIn !== null && state.currentVideoDuration > 0) { // Only Mark In is set
             const inPercent = (state.currentMarkIn / state.currentVideoDuration) * 100;
             const currentPercent = (logVideoPlayer.currentTime / state.currentVideoDuration) * 100;
             if (currentPercent > inPercent) {
                DOMElements.timelineMarkInOut.style.left = `${inPercent}%`;
                DOMElements.timelineMarkInOut.style.width = `${currentPercent - inPercent}%`;
             } else {
                DOMElements.timelineMarkInOut.style.width = '0%';    
             }
        } else {
            DOMElements.timelineMarkInOut.style.width = '0%';
        }
    }

    function handleMarkIn() {
        state.currentMarkIn = logVideoPlayer.currentTime;
        // If Mark Out is set and is before new Mark In, clear Mark Out
        if (state.currentMarkOut !== null && state.currentMarkOut < state.currentMarkIn) {
            state.currentMarkOut = null;
        }
        updateMarkInOutDisplays();
        showNotification(`Mark In set at ${formatTime(state.currentMarkIn, true)}`, "info", 1500);
    }

    function handleMarkOut() {
        state.currentMarkOut = logVideoPlayer.currentTime;
        // If Mark In is not set or is after new Mark Out, set Mark In to 0 or current Mark In
        if (state.currentMarkIn === null || state.currentMarkIn > state.currentMarkOut) {
            state.currentMarkIn = Math.min(state.currentMarkIn || 0, state.currentMarkOut); 
            // This logic might need refinement: if MarkIn is null, should it default to 0? Or require MarkIn first?
            // For now, if MarkIn is null, it will effectively use 0 if MarkOut is set.
            // Or, simply disallow Mark Out if Mark In isn't set.
            // Let's assume Mark In must be set first for a valid range.
            if (state.currentMarkIn === null) {
                 showNotification("Set Mark In first.", "error");
                 state.currentMarkOut = null; // Reset Mark Out
                 return;
            }
             if (state.currentMarkIn > state.currentMarkOut) {
                showNotification("Mark Out cannot be before Mark In. Mark In reset.", "error");
                state.currentMarkIn = state.currentMarkOut; // Or clear MarkIn
             }
        }
        updateMarkInOutDisplays();
        showNotification(`Mark Out set at ${formatTime(state.currentMarkOut, true)}`, "info", 1500);
    }

    function handleTimelineClick(event) {
        if (!logVideoPlayer || isNaN(state.currentVideoDuration) || state.currentVideoDuration === 0) return;
        const timelineRect = DOMElements.videoTimelineContainer.getBoundingClientRect();
        const clickX = event.clientX - timelineRect.left;
        const clickPercent = clickX / timelineRect.width;
        logVideoPlayer.currentTime = clickPercent * state.currentVideoDuration;
    }

    function handleStarRatingClick(event) {
        if (event.target.classList.contains('star')) {
            state.currentLogRating = parseInt(event.target.dataset.value);
            renderStarRating();
        }
    }
    
    function renderStarRating() {
        const stars = DOMElements.logRating.querySelectorAll('.star');
        stars.forEach(star => {
            star.textContent = parseInt(star.dataset.value) <= state.currentLogRating ? '★' : '☆';
            star.classList.toggle('selected', parseInt(star.dataset.value) <= state.currentLogRating);
        });
    }

    function handleKeywordInput(event) {
        if (event.key === 'Enter' && DOMElements.logKeywordsInput.value.trim() !== "") {
            event.preventDefault();
            const keyword = DOMElements.logKeywordsInput.value.trim();
            if (!currentLogKeywords.includes(keyword)) {
                currentLogKeywords.push(keyword);
                renderKeywords();
            }
            DOMElements.logKeywordsInput.value = '';
        }
    }

    function renderKeywords() {
        DOMElements.logKeywordsContainer.innerHTML = '';
        currentLogKeywords.forEach(keyword => {
            const tag = document.createElement('span');
            tag.className = 'keyword-tag';
            tag.textContent = sanitizeHTML(keyword);
            const removeBtn = document.createElement('span');
            removeBtn.className = 'remove-keyword';
            removeBtn.textContent = '×';
            removeBtn.onclick = () => {
                currentLogKeywords = currentLogKeywords.filter(k => k !== keyword);
                renderKeywords();
            };
            tag.appendChild(removeBtn);
            DOMElements.logKeywordsContainer.appendChild(tag);
        });
    }

    async function handleSaveLog() {
        const notes = DOMElements.logNotes.value.trim();
        if (state.currentMarkIn === null || state.currentMarkOut === null) {
            showNotification("Please set both Mark In and Mark Out points.", "error");
            return;
        }
        if (state.currentMarkIn >= state.currentMarkOut) {
            showNotification("Mark Out must be after Mark In.", "error");
            return;
        }

        const logData = {
            videoId: state.currentVideoId,
            projectId: state.currentProjectId,
            inTime: state.currentMarkIn,
            outTime: state.currentMarkOut,
            notes: notes,
            rating: state.currentLogRating,
            keywords: [...currentLogKeywords], // clone
            createdAt: new Date()
        };

        try {
            await dbAdd(STORE_LOGS, logData);
            showNotification("Log saved successfully.", "success");
            resetLogForm();
            loadLogsForCurrentVideo();
            // Update log count on Assembly Hub card if visible (or on next load)
            const videoCard = document.querySelector(`.video-card[data-video-id="${state.currentVideoId}"]`);
            if (videoCard) {
                const logs = await dbGetByIndex(STORE_LOGS, 'videoId', state.currentVideoId);
                videoCard.querySelector('.video-card-meta span').textContent = `${logs.length} log(s)`;
                videoCard.querySelector('.preview-selects-btn').disabled = logs.length === 0;
                 const viewLogsBtn = videoCard.querySelector('.view-video-logs-btn');
                 if (viewLogsBtn) viewLogsBtn.textContent = `View Logs (${logs.length})`;
            }

        } catch (error) {
            console.error("Error saving log:", error);
            showNotification("Failed to save log.", "error");
        }
    }

    function resetLogForm() {
        DOMElements.logNotes.value = '';
        state.currentMarkIn = null;
        state.currentMarkOut = null;
        state.currentLogRating = 0;
        currentLogKeywords = [];
        renderStarRating();
        renderKeywords();
        updateMarkInOutDisplays(); // Resets time displays and timeline marker
        DOMElements.timelineMarkInOut.style.width = '0%';
        DOMElements.timelineMarkInOut.style.left = '0%';
    }

    async function loadLogsForCurrentVideo() {
        try {
            const logs = await dbGetByIndex(STORE_LOGS, 'videoId', state.currentVideoId);
            logs.sort((a, b) => a.inTime - b.inTime); // Sort by In time

            DOMElements.savedLogsList.innerHTML = '';
            if (logs.length === 0) {
                DOMElements.loggingStationEmptyState.classList.remove('hidden');
            } else {
                DOMElements.loggingStationEmptyState.classList.add('hidden');
                logs.forEach(log => {
                    const item = document.createElement('div');
                    item.className = 'log-item';
                    item.innerHTML = `
                        <div class="log-item-header">
                            <span class="log-item-time">${formatTime(log.inTime)} - ${formatTime(log.outTime)}</span>
                            <span class="log-item-rating">${'★'.repeat(log.rating)}${'☆'.repeat(5 - log.rating)}</span>
                        </div>
                        <p class="log-item-notes">${sanitizeHTML(log.notes) || "<em>No notes</em>"}</p>
                        <div class="log-item-keywords">
                            ${log.keywords.map(k => `<span class="keyword-tag">${sanitizeHTML(k)}</span>`).join('')}
                        </div>
                        <div class="log-item-actions">
                            <button class="go-to-log-btn secondary" data-time="${log.inTime}">Go To</button>
                            <button class="delete-log-btn danger" data-log-id="${log.id}">Delete</button>
                        </div>
                    `;
                    item.querySelector('.go-to-log-btn').addEventListener('click', (e) => {
                        logVideoPlayer.currentTime = parseFloat(e.target.dataset.time);
                        logVideoPlayer.play();
                    });
                    item.querySelector('.delete-log-btn').addEventListener('click', (e) => handleDeleteLog(parseInt(e.target.dataset.logId)));
                    DOMElements.savedLogsList.appendChild(item);
                });
            }
        } catch (error) {
            console.error("Error loading logs:", error);
            showNotification("Failed to load logs.", "error");
        }
    }
    
    async function handleDeleteLog(logId) {
        const confirmed = await showConfirmDialog("Delete Log", "Are you sure you want to delete this log?", null);
        if (confirmed) {
            try {
                await dbDelete(STORE_LOGS, logId);
                showNotification("Log deleted.", "success");
                loadLogsForCurrentVideo(); // Reload logs for the current video
            } catch (err) {
                showNotification("Error deleting log.", "error");
                console.error("Error deleting log", err);
            }
        }
    }


    // --- Advanced Features ---
    let previewSelectsPlayer;
    let previewSelectsQueue = [];
    let currentPreviewSelectIndex = 0;

    async function handlePreviewSelects(videoId) {
        const videoData = await dbGetById(STORE_VIDEOS, videoId);
        const logs = await dbGetByIndex(STORE_LOGS, 'videoId', videoId);
        
        if (!videoData || !videoData.fileObject) {
            showNotification("Video file data not found for preview.", "error");
            return;
        }
        if (logs.length === 0) {
            showNotification("No logs to preview for this video.", "info");
            return;
        }

        logs.sort((a,b) => a.inTime - b.inTime);
        previewSelectsQueue = logs;
        currentPreviewSelectIndex = 0;

        previewSelectsPlayer = DOMElements.previewSelectsPlayer;
        if (previewSelectsPlayer.src && previewSelectsPlayer.src.startsWith('blob:')) {
             URL.revokeObjectURL(previewSelectsPlayer.src);
        }
        previewSelectsPlayer.src = URL.createObjectURL(videoData.fileObject);
        previewSelectsPlayer.onended = playNextSelect;
        previewSelectsPlayer.ontimeupdate = updatePreviewSelectsPlayerTime;


        DOMElements.previewSelectsModal.classList.remove('hidden');
        playNextSelect(); // Start playing the first select
    }

    function playNextSelect() {
        if (currentPreviewSelectIndex >= previewSelectsQueue.length) {
            DOMElements.previewSelectsInfo.textContent = "All selects played.";
            DOMElements.previewSelectsNotes.textContent = "";
             // Optionally close modal or offer replay
            return;
        }
        const currentSelect = previewSelectsQueue[currentPreviewSelectIndex];
        DOMElements.previewSelectsInfo.textContent = `Playing Select ${currentPreviewSelectIndex + 1} of ${previewSelectsQueue.length}`;
        DOMElements.previewSelectsNotes.textContent = currentSelect.notes || "No notes for this select.";
        
        previewSelectsPlayer.currentTime = currentSelect.inTime;
        previewSelectsPlayer.play();
        // The ontimeupdate will handle stopping at outTime
    }

    function updatePreviewSelectsPlayerTime() {
        if (!previewSelectsPlayer || previewSelectsQueue.length === 0 || currentPreviewSelectIndex >= previewSelectsQueue.length) return;

        const currentSelect = previewSelectsQueue[currentPreviewSelectIndex];
        if (previewSelectsPlayer.currentTime >= currentSelect.outTime) {
            previewSelectsPlayer.pause();
            currentPreviewSelectIndex++;
            playNextSelect();
        }
    }

    function closePreviewSelectsModal() {
        if (previewSelectsPlayer) {
            previewSelectsPlayer.pause();
            if (previewSelectsPlayer.src && previewSelectsPlayer.src.startsWith('blob:')) {
                 URL.revokeObjectURL(previewSelectsPlayer.src);
            }
            previewSelectsPlayer.src = ""; // Clear src
        }
        previewSelectsQueue = [];
        DOMElements.previewSelectsModal.classList.add('hidden');
    }

    function handleKeyboardShortcuts(event) {
        if (state.currentScreen === 'logging-station') {
            // Prevent shortcuts if typing in an input/textarea
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                return;
            }

            switch(event.key.toLowerCase()) {
                case ' ':
                    event.preventDefault();
                    if (logVideoPlayer.paused) logVideoPlayer.play();
                    else logVideoPlayer.pause();
                    break;
                case 'i':
                    event.preventDefault();
                    handleMarkIn();
                    break;
                case 'o':
                    event.preventDefault();
                    handleMarkOut();
                    break;
            }
        }
    }

    async function exportAllData() {
        const confirmed = await showConfirmDialog(
            "Export Data",
            "This will export all your projects, videos (metadata only, not files), and logs as a JSON file. Do you want to proceed?",
            null
        );
        if (!confirmed) return;

        try {
            const projects = await dbGetAll(STORE_PROJECTS);
            const videos = await dbGetAll(STORE_VIDEOS);
            const logs = await dbGetAll(STORE_LOGS);

            // Sanitize video data for export - remove actual File objects
            const videosForExport = videos.map(v => {
                const { fileObject, ...videoMeta } = v; // Destructure to remove fileObject
                return videoMeta;
            });

            const dataToExport = {
                exportDate: new Date().toISOString(),
                projects,
                videos: videosForExport,
                logs
            };

            const jsonData = JSON.stringify(dataToExport, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `LogReel_Export_${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showNotification("Data exported successfully.", "success");
        } catch (error) {
            console.error("Error exporting data:", error);
            showNotification("Failed to export data.", "error");
        }
    }


    // --- Initialization ---
    async function initApp() {
        // Cache DOM Elements
        DOMElements.projectDashboardScreen = document.getElementById('project-dashboard-screen');
        DOMElements.assemblyHubScreen = document.getElementById('assembly-hub-screen');
        DOMElements.loggingStationScreen = document.getElementById('logging-station-screen');
        
        DOMElements.createNewProjectBtn = document.getElementById('create-new-project-btn');
        DOMElements.projectList = document.getElementById('project-list');
        DOMElements.projectDashboardEmptyState = document.getElementById('project-dashboard-empty-state');
        DOMElements.exportAllDataBtn = document.getElementById('export-all-data-btn');

        DOMElements.assemblyBackToDashboardBtn = document.getElementById('assembly-back-to-dashboard-btn');
        DOMElements.assemblyProjectTitle = document.getElementById('assembly-project-title');
        DOMElements.assemblySearchBar = document.getElementById('assembly-search-bar');
        DOMElements.addVideosBtn = document.getElementById('add-videos-btn');
        DOMElements.videoFileInput = document.getElementById('video-file-input');
        DOMElements.videoList = document.getElementById('video-list');
        DOMElements.assemblyHubEmptyState = document.getElementById('assembly-hub-empty-state');

        DOMElements.loggingBackToAssemblyBtn = document.getElementById('logging-back-to-assembly-btn');
        DOMElements.loggingVideoFilename = document.getElementById('logging-video-filename');
        DOMElements.videoPlayer = document.getElementById('video-player');
        DOMElements.videoTimelineContainer = document.getElementById('video-timeline-container');
        DOMElements.timelineProgress = document.getElementById('timeline-progress');
        DOMElements.timelineMarkInOut = document.getElementById('timeline-mark-in-out');
        DOMElements.playbackSpeed = document.getElementById('playback-speed');
        DOMElements.markInBtn = document.getElementById('mark-in-btn');
        DOMElements.markOutBtn = document.getElementById('mark-out-btn');
        DOMElements.markInTimeDisplay = document.getElementById('mark-in-time-display');
        DOMElements.markOutTimeDisplay = document.getElementById('mark-out-time-display');
        DOMElements.logNotes = document.getElementById('log-notes');
        DOMElements.logRating = document.getElementById('log-rating');
        DOMElements.logKeywordsInput = document.getElementById('log-keywords-input');
        DOMElements.logKeywordsContainer = document.getElementById('log-keywords-container');
        DOMElements.saveLogBtn = document.getElementById('save-log-btn');
        DOMElements.savedLogsList = document.getElementById('saved-logs-list');
        DOMElements.loggingStationEmptyState = document.getElementById('logging-station-empty-state');

        DOMElements.previewSelectsModal = document.getElementById('preview-selects-modal');
        DOMElements.previewSelectsPlayer = document.getElementById('preview-selects-player');
        DOMElements.previewSelectsInfo = document.getElementById('preview-selects-info');
        DOMElements.previewSelectsNotes = document.getElementById('preview-selects-notes');
        
        DOMElements.confirmDialog = document.getElementById('confirm-dialog');
        DOMElements.confirmDialogTitle = document.getElementById('confirm-dialog-title');
        DOMElements.confirmDialogMessage = document.getElementById('confirm-dialog-message');
        DOMElements.confirmDialogCancelBtn = document.getElementById('confirm-dialog-cancel-btn');
        DOMElements.confirmDialogConfirmBtn = document.getElementById('confirm-dialog-confirm-btn');
        
        DOMElements.notificationsContainer = document.getElementById('notifications-container');


        // Init DB
        try {
            await initDB();
            showNotification("Application ready.", "success", 1500);
        } catch (error) {
            showNotification("Failed to initialize database. Application may not work correctly.", "error");
            console.error("DB Init failed:", error);
            // Optionally, disable app features that rely on DB
        }

        // Setup Event Listeners
        // Project Dashboard
        DOMElements.createNewProjectBtn.addEventListener('click', handleCreateNewProject);
        DOMElements.exportAllDataBtn.addEventListener('click', exportAllData);
        DOMElements.projectList.addEventListener('click', (event) => {
            if (event.target.classList.contains('delete-project-btn')) {
                const projectId = parseInt(event.target.dataset.projectId);
                handleDeleteProject(projectId);
            }
        });

        // Assembly Hub
        DOMElements.assemblyBackToDashboardBtn.addEventListener('click', () => navigateTo('project-dashboard'));
        DOMElements.addVideosBtn.addEventListener('click', handleAddVideos);
        DOMElements.videoFileInput.addEventListener('change', (event) => {
            processSelectedVideoFiles(event.target.files);
            event.target.value = null; // Reset file input
        });
        DOMElements.assemblySearchBar.addEventListener('input', handleAssemblySearch);


        // Logging Station
        DOMElements.loggingBackToAssemblyBtn.addEventListener('click', () => {
            // Clean up player before navigating away
            if (logVideoPlayer && logVideoPlayer.src && logVideoPlayer.src.startsWith('blob:')) {
                URL.revokeObjectURL(logVideoPlayer.src);
                logVideoPlayer.src = ""; // prevent video from playing in background
            }
            logVideoPlayer.onloadedmetadata = null;
            logVideoPlayer.ontimeupdate = null;
            logVideoPlayer.onseeked = null;

            navigateTo('assembly-hub', { projectId: state.currentProjectId, projectName: state.currentProjectName });
        });
        DOMElements.markInBtn.addEventListener('click', handleMarkIn);
        DOMElements.markOutBtn.addEventListener('click', handleMarkOut);
        DOMElements.videoTimelineContainer.addEventListener('click', handleTimelineClick);
        DOMElements.logRating.addEventListener('click', handleStarRatingClick);
        DOMElements.logKeywordsInput.addEventListener('keydown', handleKeywordInput);
        DOMElements.saveLogBtn.addEventListener('click', handleSaveLog);
        DOMElements.playbackSpeed.addEventListener('change', (e) => {
            if(logVideoPlayer) logVideoPlayer.playbackRate = parseFloat(e.target.value);
        });

        // Modals
        document.querySelectorAll('.close-modal-btn').forEach(btn => {
            btn.addEventListener('click', (event) => {
                const modalId = event.target.dataset.targetModal;
                if (modalId === 'preview-selects-modal') {
                    closePreviewSelectsModal();
                } else {
                    document.getElementById(modalId).classList.add('hidden');
                }
            });
        });
        DOMElements.confirmDialogCancelBtn.addEventListener('click', () => DOMElements.confirmDialog.classList.add('hidden'));


        // Global Listeners
        document.addEventListener('keydown', handleKeyboardShortcuts);
        window.addEventListener('beforeunload', (event) => {
            // Optional: Warn user if there's unsaved data or work in progress.
            // For a client-side app saving to IndexedDB, this is less critical than server-side.
            // if (state.unsavedChanges) {
            //     event.preventDefault();
            //     event.returnValue = ''; // Standard for most browsers
            // }
        });

        // Initial Render (Project Dashboard)
        navigateTo('project-dashboard');
    }

    // Start the application
    document.addEventListener('DOMContentLoaded', initApp);

})();
</script>
</body>
</html>
