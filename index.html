<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LogReel - Professional Video Logging</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <!-- Dexie.js -->
    <script src="https://unpkg.com/dexie@3/dist/dexie.js"></script> <!-- Dexie 3.x -->
    <!-- focus-trap -->
    <script src="https://unpkg.com/focus-trap@7.5.4/dist/focus-trap.umd.js"></script>
    <!-- Vue.js 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Vue Router -->
    <script src="https://unpkg.com/vue-router@4/dist/vue-router.global.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0c0a09; /* stone-950 */
            color: #e7e5e4; /* stone-200 (approx for stone-100/200) */
            overscroll-behavior: none; /* Prevents pull-to-refresh on mobile */
        }
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1c1917; /* stone-900 */
        }
        ::-webkit-scrollbar-thumb {
            background: #44403c; /* stone-700 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #57534e; /* stone-600 */
        }
        /* Base styles using @apply (Tailwind JIT CDN will process this) */
        .btn {
            @apply px-4 py-2 rounded-md font-semibold focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-stone-950 transition-colors disabled:opacity-50 disabled:cursor-not-allowed;
        }
        .btn-primary {
            @apply bg-indigo-600 hover:bg-indigo-700 text-white focus:ring-indigo-500;
        }
        .btn-secondary {
            @apply bg-stone-700 hover:bg-stone-600 text-stone-200 focus:ring-stone-500;
        }
        .btn-danger {
            @apply bg-red-600 hover:bg-red-700 text-white focus:ring-red-500;
        }
        .card {
            @apply bg-stone-900 rounded-lg shadow-md p-4 sm:p-6;
        }
        .input-field {
            @apply bg-stone-800 border border-stone-700 text-stone-200 placeholder-stone-500 text-sm rounded-lg focus:ring-indigo-500 focus:border-indigo-500 block w-full p-2.5;
        }
        .label {
            @apply block mb-2 text-sm font-medium text-stone-300;
        }
        /* Vue transitions */
        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.3s ease;
        }
        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }
        .slide-fade-enter-active {
            transition: all 0.3s ease-out;
        }
        .slide-fade-leave-active {
            transition: all 0.3s cubic-bezier(1, 0.5, 0.8, 1);
        }
        .slide-fade-enter-from,
        .slide-fade-leave-to {
            transform: translateY(20px);
            opacity: 0;
        }
        /* Ensure touch targets are large enough */
        button, [role="button"], input[type="checkbox"], input[type="radio"] {
            min-height: 44px;
            min-width: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        /* Adjust for buttons that are meant to be smaller (like icon buttons) */
        .btn-sm, .p-1 { /* specific classes for small buttons */
            min-height: auto;
            min-width: auto;
        }
        .btn { /* Padded buttons should be fine, but explicit flex align */
             display: inline-flex; align-items: center; justify-content: center;
        }
        /* Phosphor icons size */
        i.ph, i.ph-bold, i.ph-fill, i.ph-light {
             line-height: 1; /* Helps with alignment */
        }
    </style>
</head>
<body>
    <div id="app" class="antialiased">
        <router-view v-slot="{ Component }">
            <transition name="fade" mode="out-in">
                <component :is="Component" />
            </transition>
        </router-view>
        <toast-notifications></toast-notifications>
    </div>

    <script type="module">
        const { createApp, ref, reactive, computed, onMounted, onUnmounted, watch, nextTick } = Vue;
        const { createRouter, createWebHashHistory, useRoute, useRouter } = VueRouter;
        const Dexie = window.Dexie; // Dexie is global from CDN
        const focusTrap = window.focusTrap; // focus-trap is global

        // --- Database Setup (Dexie) ---
        const db = new Dexie('LogReelDB');
        db.version(1).stores({
            projects: '++id, name, createdAt',
            videos: '++id, projectId, filename, createdAt, isImportant, &[projectId+filename]',
            logs: '++id, videoId, markIn, createdAt, &[videoId+markIn]'
        });

        // --- Global State / Services ---
        const toastStore = reactive({
            toasts: [],
            addToast(message, type = 'success', duration = 3000) {
                const id = Date.now() + Math.random();
                this.toasts.push({ id, message, type });
                setTimeout(() => {
                    this.toasts = this.toasts.filter(t => t.id !== id);
                }, duration);
            }
        });

        // Helper function for File System Access API permissions
        async function verifyPermission(fileHandle, readWrite = false) {
            if (!fileHandle || typeof fileHandle.queryPermission !== 'function') {
                console.warn('Invalid fileHandle or queryPermission not available.');
                return false; // Or throw an error, depending on how you want to handle this
            }
            const options = {};
            if (readWrite) {
                options.mode = 'readwrite';
            }
            // Check current permission status
            if ((await fileHandle.queryPermission(options)) === 'granted') {
                return true;
            }
            // If not granted, request permission
            if ((await fileHandle.requestPermission(options)) === 'granted') {
                return true;
            }
            // Permission not granted
            return false;
        }
        
        // Helper to format timecodes
        const formatTimecode = (seconds, showHours = false, showMilliseconds = true) => {
            if (isNaN(seconds) || seconds === null || seconds < 0) return showMilliseconds ? '00:00.000' : '00:00';
            const hh = Math.floor(seconds / 3600);
            const mm = Math.floor((seconds % 3600) / 60);
            const ss = Math.floor(seconds % 60);
            const ms = Math.floor((seconds - Math.floor(seconds)) * 1000);

            let parts = [
                mm.toString().padStart(2, '0'),
                ss.toString().padStart(2, '0')
            ];
            if (showHours || hh > 0) {
                parts.unshift(hh.toString().padStart(2, '0'));
            }
            let timeString = parts.join(':');
            if (showMilliseconds) {
                timeString += `.${ms.toString().padStart(3, '0')}`;
            }
            return timeString;
        };


        // --- Vue Components ---

        const ToastNotifications = {
            setup() {
                return { toasts: computed(() => toastStore.toasts) };
            },
            template: `
                <div class="fixed bottom-0 right-0 p-4 space-y-2 z-[100] max-w-xs w-full">
                    <transition-group name="slide-fade" tag="div">
                        <div v-for="toast in toasts" :key="toast.id" 
                             :class="['p-3 rounded-md shadow-lg text-sm font-medium break-words', toast.type === 'success' ? 'bg-green-600 text-white' : toast.type === 'error' ? 'bg-red-600 text-white' : 'bg-blue-600 text-white']">
                            {{ toast.message }}
                        </div>
                    </transition-group>
                </div>
            `
        };

        const Modal = {
            props: {
                isOpen: Boolean,
                title: String,
            },
            emits: ['close'],
            setup(props, { emit }) {
                const modalRef = ref(null);
                let trap = null;

                const close = () => emit('close');

                watch(() => props.isOpen, (open) => {
                    nextTick(() => {
                        if (open && modalRef.value) {
                            if (!trap) {
                                trap = focusTrap.createFocusTrap(modalRef.value, {
                                    onDeactivate: close, // Automatically call close when trap deactivates
                                    clickOutsideDeactivates: true,
                                    escapeDeactivates: true,
                                    allowOutsideClick: true, // Allow clicks outside to propagate if clickOutsideDeactivates is false or handled
                                });
                            }
                            trap.activate();
                        } else if (trap && trap.active) {
                             // trap.deactivate() will be called by focus-trap itself if escapeDeactivates or clickOutsideDeactivates is true
                             // if close is called programmatically, the watch will trigger this else block.
                             // Explicitly deactivate if close was called by other means than escape/outside click.
                            trap.deactivate();
                        }
                    });
                });
                
                onUnmounted(() => {
                    if (trap && trap.active) {
                        trap.deactivate();
                    }
                    trap = null; 
                });

                return { modalRef, close };
            },
            template: `
                <transition name="fade">
                    <div v-if="isOpen" class="fixed inset-0 bg-stone-950 bg-opacity-80 flex items-center justify-center z-40 p-4" @mousedown.self="close">
                        <div ref="modalRef" class="card w-full max-w-md" role="dialog" aria-modal="true" :aria-labelledby="title ? 'modal-title' : null">
                            <div class="flex justify-between items-center mb-4">
                                <h2 v-if="title" id="modal-title" class="text-xl font-semibold text-stone-100">{{ title }}</h2>
                                <button @click="close" class="text-stone-400 hover:text-stone-200 p-1 -m-1 btn-sm" aria-label="Close modal">
                                    <i class="ph-bold ph-x text-2xl"></i>
                                </button>
                            </div>
                            <slot></slot>
                        </div>
                    </div>
                </transition>
            `
        };

        const ConfirmationModal = {
            components: { Modal },
            props: {
                isOpen: Boolean,
                title: String,
                message: String,
            },
            emits: ['confirm', 'cancel'],
            setup(props, { emit }) {
                const confirm = () => emit('confirm');
                const cancel = () => emit('cancel');
                return { confirm, cancel };
            },
            template: `
                <Modal :is-open="isOpen" :title="title" @close="cancel">
                    <p class="text-stone-300 mb-6">{{ message }}</p>
                    <div class="flex justify-end space-x-3">
                        <button @click="cancel" class="btn btn-secondary">Cancel</button>
                        <button @click="confirm" class="btn btn-danger">Confirm</button>
                    </div>
                </Modal>
            `
        };
        
        const ProjectCard = {
            components: { ConfirmationModal },
            props: ['project'],
            emits: ['delete-project', 'project-deleted'], // Added project-deleted
            setup(props, { emit }) {
                const router = useRouter();
                const videoCount = ref(0);

                const fetchVideoCount = async () => {
                    if(props.project && props.project.id) {
                       videoCount.value = await db.videos.where('projectId').equals(props.project.id).count();
                    }
                };

                onMounted(fetchVideoCount);
                watch(() => props.project.id, fetchVideoCount);

                const navigateToProject = () => {
                    router.push(`/project/${props.project.id}`);
                };
                
                const showConfirmDelete = ref(false);

                const deleteProjectConfirmed = async () => {
                    emit('delete-project', props.project.id);
                    showConfirmDelete.value = false;
                };

                return {
                    navigateToProject,
                    videoCount,
                    formattedDate: computed(() => props.project && props.project.createdAt ? new Date(props.project.createdAt).toLocaleDateString() : 'N/A'),
                    showConfirmDelete,
                    deleteProjectConfirmed,
                };
            },
            template: `
                <div class="card cursor-pointer hover:shadow-indigo-500/30 transition-shadow group" @click="navigateToProject">
                    <div class="flex justify-between items-start">
                        <h3 class="text-xl font-semibold text-stone-100 mb-2 group-hover:text-indigo-400 transition-colors">{{ project.name }}</h3>
                        <button @click.stop="showConfirmDelete = true" class="text-stone-500 hover:text-red-500 p-1 -m-1 btn-sm" aria-label="Delete project">
                            <i class="ph ph-trash text-lg"></i>
                        </button>
                    </div>
                    <p class="text-sm text-stone-400">Videos: {{ videoCount }}</p>
                    <p class="text-xs text-stone-500 mt-2">Created: {{ formattedDate }}</p>
                </div>
                <ConfirmationModal
                    :is-open="showConfirmDelete"
                    title="Delete Project?"
                    :message="'Are you sure you want to delete \'' + project.name + '\'? This will also delete all associated videos and logs.'"
                    @confirm="deleteProjectConfirmed"
                    @cancel="showConfirmDelete = false"
                />
            `
        };

        const ProjectDashboard = {
            components: { ProjectCard, Modal }, // ConfirmationModal is used by ProjectCard
            setup() {
                const projects = ref([]);
                const showNewProjectModal = ref(false);
                const newProjectName = ref('');
                const router = useRouter();

                const loadProjects = async () => {
                    projects.value = await db.projects.orderBy('createdAt').reverse().toArray();
                };

                onMounted(loadProjects);

                const createNewProject = async () => {
                    if (!newProjectName.value.trim()) {
                        toastStore.addToast('Project name cannot be empty.', 'error');
                        return;
                    }
                    try {
                        const projectId = await db.projects.add({
                            name: newProjectName.value.trim(),
                            createdAt: new Date()
                        });
                        newProjectName.value = '';
                        showNewProjectModal.value = false;
                        await loadProjects(); // Refresh list
                        toastStore.addToast('Project created!', 'success');
                        router.push(`/project/${projectId}`);
                    } catch (error) {
                        console.error("Failed to create project:", error);
                        if (error.name === 'ConstraintError') {
                             toastStore.addToast('A project with this name might already exist.', 'error');
                        } else {
                             toastStore.addToast('Failed to create project.', 'error');
                        }
                    }
                };

                const handleDeleteProject = async (projectId) => {
                    try {
                        await db.transaction('rw', db.projects, db.videos, db.logs, async () => {
                            const videosToDelete = await db.videos.where('projectId').equals(projectId).toArray();
                            const videoIdsToDelete = videosToDelete.map(v => v.id);
                            
                            if (videoIdsToDelete.length > 0) {
                                await db.logs.where('videoId').anyOf(videoIdsToDelete).delete();
                            }
                            await db.videos.where('projectId').equals(projectId).delete();
                            await db.projects.delete(projectId);
                        });
                        toastStore.addToast('Project deleted.', 'success');
                        loadProjects(); // Refresh list
                    } catch (error) {
                        console.error("Failed to delete project:", error);
                        toastStore.addToast('Error deleting project.', 'error');
                    }
                };
                
                const exportData = async () => {
                    try {
                        const allProjects = await db.projects.toArray();
                        const allVideos = await db.videos.toArray();
                        const allLogs = await db.logs.toArray();

                        const serializableVideos = allVideos.map(v => {
                            const { fileHandle, ...rest } = v; // Exclude fileHandle
                            return { ...rest, filename: v.filename }; 
                        });
                        
                        const dataToExport = {
                            appName: 'LogReel',
                            version: '1.0.0',
                            exportedAt: new Date().toISOString(),
                            data: {
                                projects: allProjects,
                                videos: serializableVideos,
                                logs: allLogs,
                            }
                        };

                        const jsonString = JSON.stringify(dataToExport, null, 2);
                        const blob = new Blob([jsonString], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `logreel_export_${new Date().toISOString().slice(0,10).replace(/-/g,'')}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        toastStore.addToast('Data exported successfully.', 'success');
                    } catch (error) {
                        console.error('Error exporting data:', error);
                        toastStore.addToast('Failed to export data.', 'error');
                    }
                };

                return {
                    projects,
                    showNewProjectModal,
                    newProjectName,
                    createNewProject,
                    handleDeleteProject,
                    exportData
                };
            },
            template: `
                <div class="min-h-screen flex flex-col">
                    <header class="bg-stone-900 shadow-md p-4 sticky top-0 z-20">
                        <div class="container mx-auto flex flex-wrap justify-between items-center gap-2">
                            <h1 class="text-2xl font-bold text-indigo-500">LogReel</h1>
                            <div class="flex items-center space-x-2">
                                <button @click="exportData" class="btn btn-secondary btn-sm md:btn-md py-1 px-2 md:py-2 md:px-4 text-xs md:text-sm">
                                    <i class="ph ph-export mr-1"></i> Export Data
                                </button>
                                <button @click="showNewProjectModal = true" class="btn btn-primary btn-sm md:btn-md py-1 px-2 md:py-2 md:px-4 text-xs md:text-sm">
                                    <i class="ph ph-plus-circle mr-1"></i> New Project
                                </button>
                            </div>
                        </div>
                    </header>

                    <main class="flex-grow container mx-auto p-4 sm:p-6">
                        <div v-if="projects.length > 0" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-6">
                            <ProjectCard v-for="project in projects" :key="project.id" :project="project" @delete-project="handleDeleteProject" />
                        </div>
                        <div v-else class="text-center py-12">
                            <i class="ph-light ph-folder-notch-open text-6xl text-stone-600 mb-4"></i>
                            <p class="text-xl text-stone-400">No projects yet.</p>
                            <p class="text-stone-500">Click "New Project" to get started.</p>
                        </div>
                    </main>

                    <Modal :is-open="showNewProjectModal" title="Create New Project" @close="showNewProjectModal = false; newProjectName = '';">
                        <form @submit.prevent="createNewProject">
                            <div class="mb-4">
                                <label for="projectName" class="label">Project Name</label>
                                <input type="text" id="projectName" v-model="newProjectName" class="input-field" required autofocus>
                            </div>
                            <div class="flex justify-end">
                                <button type="submit" class="btn btn-primary">Create Project</button>
                            </div>
                        </form>
                    </Modal>
                </div>
            `
        };

        const VideoCard = {
            components: { ConfirmationModal },
            props: {
                video: Object,
                index: Number
            },
            emits: ['toggle-importance', 'delete-video', 'play-selects', 'log-video', 'view-logs-toggled'],
            setup(props, { emit }) {
                const logCount = ref(0);
                const logs = ref([]);
                const showLogs = ref(false);

                const fetchLogData = async () => {
                    if (!props.video || !props.video.id) return;
                    logCount.value = await db.logs.where('videoId').equals(props.video.id).count();
                    if (showLogs.value) {
                         logs.value = await db.logs.where('videoId').equals(props.video.id).orderBy('markIn').toArray();
                    }
                };

                onMounted(fetchLogData);
                watch(() => [props.video.id, showLogs.value], fetchLogData, { deep: true });

                const toggleImportance = () => {
                    emit('toggle-importance', props.video.id, !props.video.isImportant);
                };
                
                const showConfirmDelete = ref(false);
                const deleteVideoConfirmed = () => {
                     emit('delete-video', props.video.id);
                     showConfirmDelete.value = false;
                };

                const logVideo = () => emit('log-video', props.video.id);
                const playSelects = () => emit('play-selects', props.video.id);
                
                const toggleViewLogs = () => {
                    showLogs.value = !showLogs.value;
                    emit('view-logs-toggled', props.video.id, showLogs.value);
                };
                
                return {
                    logCount, logs, showLogs,
                    toggleImportance, deleteVideoConfirmed, showConfirmDelete,
                    logVideo, playSelects, toggleViewLogs,
                    formatTimecode, // make it globally available or pass as prop if needed in template
                };
            },
            template: `
                <div class="card flex flex-col">
                    <div class="flex justify-between items-start mb-3">
                        <div class="flex items-center space-x-2 min-w-0"> <!-- min-w-0 for truncate -->
                            <span class="text-sm text-stone-500 shrink-0">{{ index + 1 }}.</span>
                            <h4 class="text-lg font-medium text-stone-200 truncate" :title="video.filename">{{ video.filename }}</h4>
                        </div>
                        <div class="flex items-center space-x-1 shrink-0">
                            <button @click.stop="toggleImportance" class="p-1 btn-sm" :aria-pressed="video.isImportant" aria-label="Toggle importance">
                                <i :class="['ph-star text-xl', video.isImportant ? 'ph-fill text-yellow-400' : 'ph text-stone-500 hover:text-yellow-400']"></i>
                            </button>
                            <button @click.stop="showConfirmDelete = true" class="text-stone-500 hover:text-red-500 p-1 btn-sm" aria-label="Delete video">
                                <i class="ph ph-trash text-lg"></i>
                            </button>
                        </div>
                    </div>

                    <div class="bg-stone-800 aspect-video rounded flex items-center justify-center mb-3">
                        <i class="ph ph-video text-5xl text-stone-600"></i>
                    </div>

                    <div class="flex justify-between items-center mb-3 text-xs">
                        <span class="bg-indigo-500 text-indigo-50 font-semibold px-2 py-0.5 rounded-full">{{ logCount }} Log{{ logCount !== 1 ? 's' : '' }}</span>
                        <div class="space-x-2">
                             <button @click="toggleViewLogs" class="text-indigo-400 hover:text-indigo-300">
                                <i :class="['ph text-sm mr-0.5', showLogs ? 'ph-caret-up' : 'ph-caret-down']"></i> View Logs
                            </button>
                            <button @click="playSelects" :disabled="logCount === 0" 
                                    class="btn btn-secondary py-1 px-2 !text-xs"> <!-- !text-xs to override .btn potentially -->
                                <i class="ph ph-play-circle mr-1"></i> Play Selects
                            </button>
                        </div>
                    </div>
                    
                    <button @click="logVideo" class="btn btn-primary w-full mt-auto">
                        <i class="ph ph-list-plus mr-1"></i> Log Video
                    </button>

                    <transition name="slide-fade">
                        <div v-if="showLogs" class="mt-4 pt-4 border-t border-stone-700">
                            <h5 class="text-sm font-semibold text-stone-300 mb-2">Logs:</h5>
                            <ul v-if="logs.length > 0" class="space-y-2 max-h-48 overflow-y-auto pr-1">
                                <li v-for="log_item in logs" :key="log_item.id" class="text-xs p-2 bg-stone-800 rounded">
                                    <div class="font-medium text-stone-300">{{ formatTimecode(log_item.markIn, false, false) }} - {{ formatTimecode(log_item.markOut, false, false) }}</div>
                                    <p class="text-stone-400 truncate my-0.5" :title="log_item.notes">{{ log_item.notes || 'No notes' }}</p>
                                    <div class="flex items-center">
                                        <i v-for="n in 5" :key="n" :class="['ph-star text-sm', n <= log_item.rating ? 'ph-fill text-yellow-400' : 'ph text-stone-600']"></i>
                                    </div>
                                    <div v-if="log_item.keywords && log_item.keywords.length" class="mt-1 flex flex-wrap gap-1">
                                        <span v-for="kw in log_item.keywords" :key="kw" class="text-indigo-300 bg-indigo-800/60 px-1.5 py-0.5 rounded text-[0.7rem] leading-none">{{ kw }}</span>
                                    </div>
                                </li>
                            </ul>
                            <p v-else class="text-xs text-stone-500">No logs for this video yet.</p>
                        </div>
                    </transition>
                    <ConfirmationModal
                        :is-open="showConfirmDelete"
                        title="Delete Video?"
                        message="Are you sure you want to delete this video and all its logs? This action cannot be undone."
                        @confirm="deleteVideoConfirmed"
                        @cancel="showConfirmDelete = false"
                    />
                </div>
            `
        };

        const AssemblyHub = {
            components: { VideoCard, ConfirmationModal },
            setup() {
                const route = useRoute();
                const router = useRouter();
                const projectId = computed(() => route.params.id ? parseInt(route.params.id) : null);
                const project = ref(null);
                const videos = ref([]);
                const searchTerm = ref('');
                
                const showPlaySelectsModal = ref(false);
                const playSelectsModalContentRef = ref(null);
                const videoForPlaySelects = ref(null);
                const logsForPlaySelects = ref([]);
                const currentPlayingSelectIndex = ref(0);
                const playSelectsVideoPlayerRef = ref(null);
                let playSelectsTrap = null;


                const loadProjectData = async () => {
                    if (!projectId.value) {
                         router.push('/'); return;
                    }
                    project.value = await db.projects.get(projectId.value);
                    if (!project.value) {
                        toastStore.addToast('Project not found.', 'error');
                        router.push('/');
                        return;
                    }
                    await loadVideos();
                };

                const loadVideos = async () => {
                    if (!projectId.value) return;
                    const allProjectVideos = await db.videos.where('projectId').equals(projectId.value).sortBy('createdAt');
                    
                    if (!searchTerm.value.trim()) {
                        videos.value = allProjectVideos;
                        return;
                    }

                    const lowerSearchTerm = searchTerm.value.toLowerCase();
                    const videoIdsWithMatchingLogs = new Set();
                    
                    if (allProjectVideos.length > 0) {
                        const projectVideoIds = allProjectVideos.map(v => v.id);
                        const allLogsForProject = await db.logs.where('videoId').anyOf(projectVideoIds).toArray();
                        
                        allLogsForProject.forEach(log => {
                            const notesMatch = log.notes && log.notes.toLowerCase().includes(lowerSearchTerm);
                            const keywordsMatch = log.keywords && log.keywords.some(kw => kw.toLowerCase().includes(lowerSearchTerm));
                            if (notesMatch || keywordsMatch) {
                                videoIdsWithMatchingLogs.add(log.videoId);
                            }
                        });
                    }

                    videos.value = allProjectVideos.filter(video => 
                        video.filename.toLowerCase().includes(lowerSearchTerm) ||
                        videoIdsWithMatchingLogs.has(video.id)
                    );
                };
                
                let debounceTimer;
                watch(searchTerm, () => {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(loadVideos, 300);
                });

                onMounted(loadProjectData);
                watch(projectId, (newId, oldId) => {
                    if (newId !== oldId) loadProjectData();
                }, { immediate: true });

                const addVideos = async () => {
                    if (!('showOpenFilePicker' in window)) {
                        toastStore.addToast('File System Access API is not supported.', 'error', 5000);
                        return;
                    }
                    try {
                        const fileHandles = await window.showOpenFilePicker({
                            multiple: true,
                            types: [{
                                description: 'Video files',
                                accept: { 'video/*': ['.mp4', '.mov', '.avi', '.mkv', '.webm'] }
                            }]
                        });

                        let addedCount = 0;
                        for (const handle of fileHandles) {
                            const existingVideo = await db.videos.get({ projectId: projectId.value, filename: handle.name });
                            if (existingVideo) {
                                toastStore.addToast(`Video "${handle.name}" already exists.`, 'info');
                                continue;
                            }
                            await db.videos.add({
                                projectId: projectId.value,
                                filename: handle.name,
                                fileHandle: handle,
                                isImportant: false,
                                createdAt: new Date()
                            });
                            addedCount++;
                        }
                        if (addedCount > 0) {
                           await loadVideos();
                           toastStore.addToast(`${addedCount} video(s) added.`, 'success');
                        }
                    } catch (err) {
                        if (err.name === 'AbortError') {
                            // User cancelled, do nothing or show info toast
                        } else {
                            console.error("Error adding videos:", err);
                            toastStore.addToast('Error adding videos. Check permissions or console.', 'error');
                        }
                    }
                };

                const handleToggleImportance = async (videoId, newImportance) => {
                    await db.videos.update(videoId, { isImportant: newImportance });
                    const videoToUpdate = videos.value.find(v => v.id === videoId);
                    if (videoToUpdate) videoToUpdate.isImportant = newImportance;
                };

                const handleDeleteVideo = async (videoId) => {
                    try {
                        await db.transaction('rw', db.videos, db.logs, async () => {
                            await db.logs.where('videoId').equals(videoId).delete();
                            await db.videos.delete(videoId);
                        });
                        toastStore.addToast('Video deleted.', 'success');
                        await loadVideos(); // Refresh list
                    } catch (error) {
                        console.error("Failed to delete video:", error);
                        toastStore.addToast('Error deleting video.', 'error');
                    }
                };
                
                const handleLogVideo = (videoId) => {
                    router.push(`/video/${videoId}`);
                };

                const openPlaySelectsModal = async (videoId) => {
                    const selectedVideo = await db.videos.get(videoId);
                    if (!selectedVideo) {
                        toastStore.addToast('Video not found for Play Selects.', 'error');
                        return;
                    }
                    videoForPlaySelects.value = selectedVideo;
                    
                    logsForPlaySelects.value = await db.logs.where('videoId').equals(videoId).orderBy('markIn').toArray();
                    if (logsForPlaySelects.value.length === 0) {
                        toastStore.addToast('No logs to play for this video.', 'info');
                        return;
                    }
                    currentPlayingSelectIndex.value = 0;
                    showPlaySelectsModal.value = true; // This will trigger the watcher for focus trap
                    nextTick(playCurrentSelect); // Start playing after modal is rendered
                };

                const closePlaySelectsModal = () => {
                    showPlaySelectsModal.value = false; // Triggers watcher to deactivate trap
                    if (playSelectsVideoPlayerRef.value) {
                        playSelectsVideoPlayerRef.value.pause();
                        if (playSelectsVideoPlayerRef.value.src) {
                            URL.revokeObjectURL(playSelectsVideoPlayerRef.value.src); // Important: Release object URL
                        }
                        playSelectsVideoPlayerRef.value.src = ''; 
                    }
                    videoForPlaySelects.value = null;
                    logsForPlaySelects.value = [];
                };
                
                watch(showPlaySelectsModal, (isOpen) => {
                    nextTick(() => { // Ensure DOM is updated
                        if (isOpen && playSelectsModalContentRef.value) {
                            if (!playSelectsTrap) {
                                playSelectsTrap = focusTrap.createFocusTrap(playSelectsModalContentRef.value, {
                                    onDeactivate: closePlaySelectsModal,
                                    clickOutsideDeactivates: false, // Fullscreen modal
                                    escapeDeactivates: true,
                                    initialFocus: playSelectsVideoPlayerRef.value || playSelectsModalContentRef.value.querySelector('button[aria-label="Close Play Selects"]')
                                });
                            }
                            playSelectsTrap.activate();
                        } else if (playSelectsTrap && playSelectsTrap.active) {
                            playSelectsTrap.deactivate();
                        }
                    });
                });
                
                onUnmounted(() => {
                    if (playSelectsTrap && playSelectsTrap.active) {
                        playSelectsTrap.deactivate();
                    }
                    playSelectsTrap = null;
                    // Also ensure video object URL is revoked if modal was open
                    if (playSelectsVideoPlayerRef.value && playSelectsVideoPlayerRef.value.src) {
                        URL.revokeObjectURL(playSelectsVideoPlayerRef.value.src);
                    }
                });

                const playCurrentSelect = async () => {
                    if (!videoForPlaySelects.value || !playSelectsVideoPlayerRef.value || currentPlayingSelectIndex.value >= logsForPlaySelects.value.length) {
                        if (logsForPlaySelects.value.length > 0 && currentPlayingSelectIndex.value >= logsForPlaySelects.value.length) {
                             toastStore.addToast('Finished playing all selects.', 'success');
                        }
                        return;
                    }

                    const logEntry = logsForPlaySelects.value[currentPlayingSelectIndex.value];
                    const videoPlayer = playSelectsVideoPlayerRef.value;

                    try {
                        const hasPermission = await verifyPermission(videoForPlaySelects.value.fileHandle);
                        if (!hasPermission) {
                            toastStore.addToast('Permission denied for video file.', 'error');
                            closePlaySelectsModal();
                            return;
                        }
                        const file = await videoForPlaySelects.value.fileHandle.getFile();
                        
                        // Revoke previous object URL if any, before setting new one
                        if (videoPlayer.src) {
                            URL.revokeObjectURL(videoPlayer.src);
                        }
                        videoPlayer.src = URL.createObjectURL(file);
                        
                        videoPlayer.onloadedmetadata = () => {
                            videoPlayer.currentTime = logEntry.markIn;
                            videoPlayer.play().catch(e => console.error("Play interrupted or failed:", e));
                        };
                        
                        const timeUpdateHandler = () => {
                            if (videoPlayer.currentTime >= logEntry.markOut) {
                                videoPlayer.pause();
                                videoPlayer.removeEventListener('timeupdate', timeUpdateHandler); // Clean up listener
                                currentPlayingSelectIndex.value++;
                                if (currentPlayingSelectIndex.value < logsForPlaySelects.value.length) {
                                    playCurrentSelect();
                                } else {
                                    toastStore.addToast('Finished playing all selects.', 'success');
                                }
                            }
                        };
                        videoPlayer.addEventListener('timeupdate', timeUpdateHandler);

                        videoPlayer.onerror = (e) => {
                             console.error("Error playing video in selects modal:", e, videoPlayer.error);
                             toastStore.addToast('Error playing video for selects.', 'error');
                             closePlaySelectsModal();
                        }
                    } catch (error) {
                        console.error("Error setting up video for play selects:", error);
                        toastStore.addToast('Failed to load video for Play Selects.', 'error');
                        closePlaySelectsModal();
                    }
                };
                
                const currentSelectLog = computed(() => {
                    if (showPlaySelectsModal.value && logsForPlaySelects.value.length > 0 && currentPlayingSelectIndex.value < logsForPlaySelects.value.length) {
                        return logsForPlaySelects.value[currentPlayingSelectIndex.value];
                    }
                    return null;
                });

                return {
                    project, videos, searchTerm,
                    addVideos, handleToggleImportance, handleDeleteVideo, handleLogVideo,
                    router,
                    openPlaySelectsModal, closePlaySelectsModal, showPlaySelectsModal,
                    playSelectsModalContentRef, playSelectsVideoPlayerRef,
                    currentPlayingSelectIndex, logsForPlaySelects, currentSelectLog, videoForPlaySelects,
                };
            },
            template: `
                <div class="min-h-screen flex flex-col">
                    <header class="bg-stone-900 shadow-md p-4 sticky top-0 z-20">
                        <div class="container mx-auto flex flex-col sm:flex-row justify-between items-center gap-3">
                            <div class="flex items-center">
                                <button @click="router.push('/')" class="text-indigo-400 hover:text-indigo-300 mr-2 p-1 btn-sm" aria-label="Back to projects">
                                    <i class="ph-bold ph-arrow-left text-2xl"></i>
                                </button>
                                <h2 class="text-xl font-semibold text-stone-100 truncate" :title="project?.name">
                                    {{ project?.name || 'Loading...' }}
                                </h2>
                            </div>
                            <div class="flex items-center space-x-2 w-full sm:w-auto">
                                <input type="search" v-model="searchTerm" placeholder="Search videos & logs..." class="input-field flex-grow sm:w-64 !py-2">
                                <button @click="addVideos" class="btn btn-primary whitespace-nowrap !py-2">
                                    <i class="ph ph-plus-circle mr-1"></i> Add Videos
                                </button>
                            </div>
                        </div>
                    </header>

                    <main class="flex-grow container mx-auto p-4 sm:p-6">
                        <div v-if="videos.length > 0" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-6">
                            <VideoCard v-for="(video, index) in videos" 
                                       :key="video.id" 
                                       :video="video" 
                                       :index="index"
                                       @toggle-importance="handleToggleImportance"
                                       @delete-video="handleDeleteVideo"
                                       @log-video="handleLogVideo"
                                       @play-selects="openPlaySelectsModal"
                            />
                        </div>
                        <div v-else-if="project" class="text-center py-12">
                            <i class="ph-light ph-video text-6xl text-stone-600 mb-4"></i>
                            <p class="text-xl text-stone-400" v-if="!searchTerm">No videos in this project yet.</p>
                            <p class="text-xl text-stone-400" v-else>No videos match your search.</p>
                            <p class="text-stone-500" v-if="!searchTerm">Click "Add Videos" to import some.</p>
                        </div>
                         <div v-else class="text-center py-12">
                            <i class="ph-light ph-spinner-gap text-6xl text-stone-600 mb-4 animate-spin"></i>
                            <p class="text-xl text-stone-400">Loading project data...</p>
                        </div>
                    </main>

                    <!-- Play Selects Modal -->
                    <transition name="fade">
                        <div v-if="showPlaySelectsModal" class="fixed inset-0 bg-stone-950 bg-opacity-95 flex flex-col items-center justify-center z-50 p-4">
                            <div ref="playSelectsModalContentRef" class="w-full h-full flex flex-col items-center justify-center relative outline-none" tabindex="-1">
                                <button @click="closePlaySelectsModal" class="absolute top-4 right-4 text-stone-300 hover:text-white z-[51] p-2 btn-sm bg-black/30 rounded-full" aria-label="Close Play Selects">
                                    <i class="ph-bold ph-x text-3xl"></i>
                                </button>
                                
                                <div v-if="videoForPlaySelects" class="text-center mb-4 text-stone-200">
                                    <p>Playing Select {{ currentPlayingSelectIndex + 1 }} of {{ logsForPlaySelects.length }}</p>
                                    <p class="text-sm text-stone-400">Video: {{ videoForPlaySelects.filename }}</p>
                                </div>

                                <video ref="playSelectsVideoPlayerRef" class="max-w-[90vw] max-h-[70vh] bg-black rounded outline-none" controlslist="nodownload nofullscreen noremoteplayback"></video>
                                
                                <div v-if="currentSelectLog" class="mt-4 p-4 bg-stone-900 rounded-lg max-w-2xl w-full text-left max-h-32 overflow-y-auto">
                                    <h4 class="text-md font-semibold text-indigo-400">Notes:</h4>
                                    <p class="text-stone-300 text-sm whitespace-pre-wrap">{{ currentSelectLog.notes || 'No notes for this select.' }}</p>
                                </div>
                                <div v-else-if="!currentSelectLog && videoForPlaySelects" class="mt-4 p-4 bg-stone-900 rounded-lg max-w-2xl w-full text-left">
                                     <p class="text-stone-400 text-sm">Loading select info...</p>
                                </div>
                            </div>
                        </div>
                    </transition>
                </div>
            `
        };
        
        const LoggingStation = {
            components: { ConfirmationModal },
            setup() {
                const route = useRoute();
                const router = useRouter();
                const videoId = computed(() => route.params.id ? parseInt(route.params.id) : null);
                
                const videoData = ref(null);
                const videoPlayerRef = ref(null);
                const timelineRef = ref(null);
                const videoSrc = ref(null);

                const currentTime = ref(0);
                const duration = ref(0);
                const isPlaying = ref(false);
                const showControls = ref(false); // HTML5 video controls

                const markIn = ref(null);
                const markOut = ref(null);

                const logForm = reactive({
                    notes: '',
                    rating: 0,
                    keywordsText: '',
                    keywords: [],
                });

                const logs = ref([]);
                const logToDelete = ref(null);

                const loadVideoAndLogs = async () => {
                    if (!videoId.value) { router.push('/'); return; }
                    
                    videoData.value = await db.videos.get(videoId.value);
                    if (!videoData.value) {
                        toastStore.addToast('Video not found.', 'error');
                        router.push(videoData.value?.projectId ? `/project/${videoData.value.projectId}` : '/');
                        return;
                    }

                    try {
                        const hasPermission = await verifyPermission(videoData.value.fileHandle);
                        if (!hasPermission) {
                            toastStore.addToast('Permission denied for video file access.', 'error', 5000);
                            return; // User may need to re-add video or browser may prompt for permission
                        }
                        const file = await videoData.value.fileHandle.getFile();
                        if (videoSrc.value) URL.revokeObjectURL(videoSrc.value); // Revoke old src if any
                        videoSrc.value = URL.createObjectURL(file);
                    } catch (err) {
                        console.error("Error loading video file:", err);
                        toastStore.addToast('Failed to load video file. It might be corrupted or inaccessible.', 'error', 5000);
                        videoSrc.value = null; // Ensure no broken player
                    }
                    await loadLogs();
                };

                const handleLoadedMetadata = () => duration.value = videoPlayerRef.value?.duration || 0;
                const handleTimeUpdate = () => currentTime.value = videoPlayerRef.value?.currentTime || 0;
                const handlePlay = () => isPlaying.value = true;
                const handlePause = () => isPlaying.value = false;
                const handleEnded = () => {
                    isPlaying.value = false;
                    currentTime.value = duration.value; // Ensure currentTime is at the end
                };
                const videoError = (e) => {
                    console.error("Video Error:", e, videoPlayerRef.value?.error);
                    toastStore.addToast('Error playing video. The file might be unsupported or corrupted.', 'error', 5000);
                    videoSrc.value = null; // Clear src to stop further errors
                };


                onMounted(() => {
                    loadVideoAndLogs();
                    const player = videoPlayerRef.value;
                    if (player) {
                        player.addEventListener('loadedmetadata', handleLoadedMetadata);
                        player.addEventListener('timeupdate', handleTimeUpdate);
                        player.addEventListener('play', handlePlay);
                        player.addEventListener('pause', handlePause);
                        player.addEventListener('ended', handleEnded);
                        player.addEventListener('error', videoError);
                    }
                    document.addEventListener('keydown', handleGlobalKeydown);
                });

                onUnmounted(() => {
                    const player = videoPlayerRef.value;
                    if (player) {
                        player.removeEventListener('loadedmetadata', handleLoadedMetadata);
                        player.removeEventListener('timeupdate', handleTimeUpdate);
                        player.removeEventListener('play', handlePlay);
                        player.removeEventListener('pause', handlePause);
                        player.removeEventListener('ended', handleEnded);
                        player.removeEventListener('error', videoError);
                    }
                    if (videoSrc.value) {
                        URL.revokeObjectURL(videoSrc.value);
                    }
                    document.removeEventListener('keydown', handleGlobalKeydown);
                });
                
                const togglePlayPause = () => {
                    if (!videoPlayerRef.value || !videoSrc.value) return;
                    if (videoPlayerRef.value.paused || videoPlayerRef.value.ended) {
                        videoPlayerRef.value.play().catch(e => console.warn("Play interrupted:", e));
                    } else {
                        videoPlayerRef.value.pause();
                    }
                };

                const seekOnTimeline = (event) => {
                    if (!timelineRef.value || !duration.value || !videoSrc.value) return;
                    const timelineRect = timelineRef.value.getBoundingClientRect();
                    const clickX = event.clientX - timelineRect.left;
                    const percentage = Math.max(0, Math.min(1, clickX / timelineRect.width));
                    videoPlayerRef.value.currentTime = duration.value * percentage;
                };

                const currentProgressPercent = computed(() => duration.value ? (currentTime.value / duration.value) * 100 : 0);
                const markInPercent = computed(() => (markIn.value !== null && duration.value) ? (markIn.value / duration.value) * 100 : null);
                const markOutPercent = computed(() => (markOut.value !== null && duration.value) ? (markOut.value / duration.value) * 100 : null);
                
                const showHoursInTimecode = computed(() => duration.value >= 3600);

                const setMarkIn = () => {
                    if (!videoSrc.value) return;
                    markIn.value = currentTime.value;
                    if (markOut.value !== null && markOut.value < markIn.value) {
                        markOut.value = null; 
                    }
                };
                const setMarkOut = () => {
                    if (!videoSrc.value) return;
                    markOut.value = currentTime.value;
                     if (markIn.value !== null && markOut.value < markIn.value) {
                        markIn.value = markOut.value;
                        toastStore.addToast('Mark In adjusted as it was after Mark Out.', 'info');
                    }
                };
                
                watch(() => logForm.keywordsText, (newVal) => {
                    logForm.keywords = newVal.split(/[,;]+/).map(kw => kw.trim()).filter(kw => kw.length > 0);
                });

                const removeKeyword = (index) => {
                    logForm.keywords.splice(index, 1);
                    logForm.keywordsText = logForm.keywords.join(', ');
                };
                
                const saveLog = async () => {
                    if (markIn.value === null || markOut.value === null) {
                        toastStore.addToast('Set Mark In and Mark Out.', 'error'); return;
                    }
                    if (markIn.value >= markOut.value) {
                        toastStore.addToast('Mark In must be before Mark Out.', 'error'); return;
                    }
                    if (!logForm.notes.trim() && logForm.rating === 0 && logForm.keywords.length === 0) {
                        toastStore.addToast('Add notes, rating, or keywords.', 'error'); return;
                    }

                    try {
                        await db.logs.add({
                            videoId: videoId.value,
                            notes: logForm.notes.trim(),
                            rating: logForm.rating,
                            keywords: [...logForm.keywords],
                            markIn: markIn.value,
                            markOut: markOut.value,
                            createdAt: new Date()
                        });
                        toastStore.addToast('Log saved!', 'success');
                        logForm.notes = ''; logForm.rating = 0; logForm.keywordsText = ''; logForm.keywords = [];
                        markIn.value = null; markOut.value = null;
                        await loadLogs();
                    } catch (error) {
                        console.error("Failed to save log:", error);
                        if (error.name === 'ConstraintError') {
                            toastStore.addToast('Log at this Mark In time already exists.', 'error');
                        } else {
                            toastStore.addToast('Error saving log.', 'error');
                        }
                    }
                };

                const loadLogs = async () => {
                    if (!videoId.value) return;
                    logs.value = await db.logs.where('videoId').equals(videoId.value).orderBy('markIn').toArray();
                };

                const goToLogTime = (seconds) => {
                    if (videoPlayerRef.value && videoSrc.value) {
                        videoPlayerRef.value.currentTime = seconds;
                        if (videoPlayerRef.value.paused) videoPlayerRef.value.play().catch(e => console.warn("Play interrupted:", e));
                    }
                };

                const confirmDeleteLog = (logId) => logToDelete.value = logId;

                const deleteLog = async () => {
                    if (!logToDelete.value) return;
                    try {
                        await db.logs.delete(logToDelete.value);
                        toastStore.addToast('Log deleted.', 'success');
                        logToDelete.value = null;
                        await loadLogs();
                    } catch (error) {
                        console.error("Failed to delete log:", error);
                        toastStore.addToast('Error deleting log.', 'error');
                    }
                };

                const handleGlobalKeydown = (event) => {
                    const activeElement = document.activeElement;
                    const inInputField = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA');

                    if (event.code === 'Space' && !inInputField && videoSrc.value) {
                        event.preventDefault(); togglePlayPause();
                    } else if (event.key.toLowerCase() === 'i' && !inInputField && videoSrc.value) {
                        event.preventDefault(); setMarkIn();
                    } else if (event.key.toLowerCase() === 'o' && !inInputField && videoSrc.value) {
                        event.preventDefault(); setMarkOut();
                    }
                };

                return {
                    videoData, videoPlayerRef, timelineRef, videoSrc,
                    currentTime, duration, isPlaying, showHoursInTimecode, showControls,
                    formatTimecode,
                    togglePlayPause, seekOnTimeline, currentProgressPercent,
                    markIn, markOut, setMarkIn, setMarkOut,
                    markInPercent, markOutPercent,
                    logForm, saveLog, removeKeyword,
                    logs, goToLogTime, confirmDeleteLog, deleteLog, logToDelete,
                    router,
                    projectId // for back button
                };
            },
            template: `
                <div class="h-screen flex flex-col bg-stone-950">
                    <header class="bg-stone-900 shadow-md p-3 sm:p-4 flex items-center shrink-0 z-10">
                        <button @click="router.push(videoData ? \`/project/\${videoData.projectId}\` : '/')" 
                                class="text-indigo-400 hover:text-indigo-300 mr-3 p-1 btn-sm" aria-label="Back to project">
                            <i class="ph-bold ph-arrow-left text-2xl"></i>
                        </button>
                        <h2 class="text-lg sm:text-xl font-semibold text-stone-100 truncate" :title="videoData?.filename">
                            {{ videoData?.filename || 'Loading video...' }}
                        </h2>
                    </header>

                    <div class="flex-grow overflow-y-auto" v-if="videoData">
                        <div class="max-w-5xl mx-auto p-3 sm:p-4">
                            <div class="sticky top-0 bg-stone-950 z-5 py-4">
                                <div class="relative group/videoplayer">
                                    <video ref="videoPlayerRef" :src="videoSrc" 
                                           class="w-full max-h-[60vh] bg-black rounded aspect-video outline-none" 
                                           :controls="showControls"
                                           @click="togglePlayPause"
                                           @dblclick="showControls = !showControls"
                                           preload="metadata"
                                           > Your browser does not support the video tag. </video>
                                    <div v-if="!videoSrc && videoData" class="absolute inset-0 flex flex-col items-center justify-center bg-black/80 rounded">
                                        <i class="ph-bold ph-warning-circle text-4xl text-yellow-400 mb-2"></i>
                                        <p class="text-stone-300">Video could not be loaded.</p>
                                        <p class="text-xs text-stone-400">Check permissions or file integrity.</p>
                                    </div>
                                    <div v-if="!showControls && videoSrc" @click="togglePlayPause" class="absolute inset-0 flex items-center justify-center opacity-0 group-hover/videoplayer:opacity-100 transition-opacity bg-black/20 cursor-pointer">
                                        <i :class="['ph-bold text-6xl text-white/80', isPlaying ? 'ph-pause-circle' : 'ph-play-circle']"></i>
                                    </div>
                                </div>
                                
                                <div v-if="videoSrc" ref="timelineRef" @click="seekOnTimeline" class="mt-3 h-5 bg-stone-800 rounded cursor-pointer relative group/timeline">
                                    <div class="h-full bg-stone-600 rounded" :style="{ width: currentProgressPercent + '%' }"></div>
                                    <div v-if="markInPercent !== null && markOutPercent !== null && markOutPercent > markInPercent" 
                                         class="absolute top-0 h-full bg-indigo-600/50 rounded pointer-events-none"
                                         :style="{ left: markInPercent + '%', width: (markOutPercent - markInPercent) + '%' }">
                                    </div>
                                    <div v-if="markInPercent !== null" 
                                         class="absolute top-0 h-full w-1 bg-indigo-400 pointer-events-none" 
                                         :style="{ left: markInPercent + '%' }">
                                        <span class="absolute -top-6 left-1/2 -translate-x-1/2 text-xs text-indigo-300 bg-stone-700 px-1 rounded opacity-0 group-hover/timeline:opacity-100 transition-opacity whitespace-nowrap">IN</span>
                                    </div>
                                    <div v-if="markOutPercent !== null" 
                                         class="absolute top-0 h-full w-1 bg-indigo-400 pointer-events-none" 
                                         :style="{ left: markOutPercent + '%' }">
                                         <span class="absolute -top-6 left-1/2 -translate-x-1/2 text-xs text-indigo-300 bg-stone-700 px-1 rounded opacity-0 group-hover/timeline:opacity-100 transition-opacity whitespace-nowrap">OUT</span>
                                    </div>
                                     <div class="absolute -bottom-6 left-0 text-xs text-stone-400 pointer-events-none">{{ formatTimecode(currentTime, showHoursInTimecode) }}</div>
                                     <div class="absolute -bottom-6 right-0 text-xs text-stone-400 pointer-events-none">{{ formatTimecode(duration, showHoursInTimecode) }}</div>
                                </div>
                                <div v-else class="mt-3 h-5 bg-stone-800 rounded flex items-center justify-center">
                                    <p class="text-xs text-stone-500">Video timeline unavailable</p>
                                </div>
                            </div>

                            <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 sm:gap-4 my-4 sm:my-6 items-center">
                                <button @click="togglePlayPause" :disabled="!videoSrc" class="btn btn-secondary col-span-1 sm:col-span-1 flex items-center justify-center text-lg py-3">
                                    <i :class="['ph-bold text-2xl mr-2', isPlaying ? 'ph-pause' : 'ph-play']"></i>
                                    <span>{{ isPlaying ? 'Pause' : 'Play' }} (Space)</span>
                                </button>
                                <button @click="setMarkIn" :disabled="!videoSrc" class="btn btn-secondary flex items-center justify-center py-3">
                                    <span class="text-indigo-400 mr-2 font-bold">I</span> Mark In: {{ markIn !== null ? formatTimecode(markIn, showHoursInTimecode) : '--:--.---' }}
                                </button>
                                <button @click="setMarkOut" :disabled="!videoSrc" class="btn btn-secondary flex items-center justify-center py-3">
                                    <span class="text-indigo-400 mr-2 font-bold">O</span> Mark Out: {{ markOut !== null ? formatTimecode(markOut, showHoursInTimecode) : '--:--.---' }}
                                </button>
                            </div>

                            <form @submit.prevent="saveLog" class="card mb-6">
                                <h3 class="text-xl font-semibold text-stone-100 mb-4">Create Log Entry</h3>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div>
                                        <label for="notes" class="label">Notes</label>
                                        <textarea id="notes" v-model="logForm.notes" rows="4" class="input-field" placeholder="Enter notes for this segment..."></textarea>
                                    </div>
                                    <div>
                                        <label class="label">Rating</label>
                                        <div class="flex space-x-1 mb-4">
                                            <button type="button" v-for="star in 5" :key="star" @click="logForm.rating = star" class="focus:outline-none p-1 btn-sm" :aria-label="'Rate ' + star + ' star' + (star > 1 ? 's' : '')">
                                                <i :class="['ph-star text-3xl transition-colors', star <= logForm.rating ? 'ph-fill text-yellow-400' : 'ph text-stone-600 hover:text-yellow-300']"></i>
                                            </button>
                                        </div>
                                        
                                        <label for="keywords" class="label">Keywords (comma/semicolon separated)</label>
                                        <input type="text" id="keywords" v-model="logForm.keywordsText" class="input-field" placeholder="e.g., b-roll, interview, good take">
                                        <div class="mt-2 flex flex-wrap gap-1.5" v-if="logForm.keywords.length > 0">
                                            <span v-for="(kw, index) in logForm.keywords" :key="index" class="bg-indigo-600 text-indigo-50 text-xs px-2 py-1 rounded-full flex items-center">
                                                {{ kw }}
                                                <button type="button" @click="removeKeyword(index)" class="ml-1.5 text-indigo-200 hover:text-white p-0.5 btn-sm" aria-label="Remove keyword">
                                                    <i class="ph-bold ph-x text-[0.6rem]"></i>
                                                </button>
                                            </span>
                                        </div>
                                    </div>
                                </div>
                                <div class="mt-6 flex justify-end">
                                    <button type="submit" class="btn btn-primary" :disabled="!videoSrc">Save Log</button>
                                </div>
                            </form>

                            <div v-if="logs.length > 0">
                                <h3 class="text-xl font-semibold text-stone-100 mb-4">Saved Logs ({{ logs.length }})</h3>
                                <div class="space-y-4">
                                    <div v-for="log_item in logs" :key="log_item.id" class="card bg-stone-800/50">
                                        <div class="flex flex-col sm:flex-row justify-between items-start gap-2">
                                            <div class="flex-grow min-w-0"> <!-- For text wrapping -->
                                                <div class="font-semibold text-indigo-400 mb-1">
                                                    {{ formatTimecode(log_item.markIn, showHoursInTimecode) }} - {{ formatTimecode(log_item.markOut, showHoursInTimecode) }}
                                                </div>
                                                <div class="flex items-center mb-1">
                                                    <i v-for="n in 5" :key="n" :class="['ph-star text-lg mr-0.5', n <= log_item.rating ? 'ph-fill text-yellow-400' : 'ph text-stone-600']"></i>
                                                </div>
                                                <p class="text-stone-300 text-sm whitespace-pre-wrap break-words mb-2">{{ log_item.notes || 'No notes.' }}</p>
                                                <div v-if="log_item.keywords && log_item.keywords.length" class="flex flex-wrap gap-1.5">
                                                    <span v-for="kw in log_item.keywords" :key="kw" class="text-indigo-300 bg-indigo-800/60 px-2 py-0.5 rounded-full text-xs">{{ kw }}</span>
                                                </div>
                                            </div>
                                            <div class="flex sm:flex-col items-end sm:items-center gap-2 shrink-0 self-start sm:self-center">
                                                <button @click="goToLogTime(log_item.markIn)" class="btn btn-secondary !py-1 !px-2 !text-xs whitespace-nowrap" :disabled="!videoSrc">
                                                    <i class="ph ph-play-circle mr-1"></i> Go
                                                </button>
                                                <button @click="confirmDeleteLog(log_item.id)" class="text-stone-500 hover:text-red-500 p-1 btn-sm" aria-label="Delete log">
                                                    <i class="ph ph-trash text-lg"></i>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                             <div v-else-if="videoData" class="text-center py-8">
                                <i class="ph-light ph-list-checks text-5xl text-stone-600 mb-3"></i>
                                <p class="text-stone-400">No logs saved for this video yet.</p>
                            </div>
                        </div>
                    </div>
                     <div v-else class="flex-grow flex items-center justify-center">
                        <i class="ph-light ph-spinner-gap text-6xl text-stone-600 mb-4 animate-spin"></i>
                        <p class="text-xl text-stone-400">Loading video data...</p>
                    </div>

                     <ConfirmationModal
                        :is-open="!!logToDelete"
                        title="Delete Log?"
                        message="Are you sure you want to delete this log entry? This action cannot be undone."
                        @confirm="deleteLog"
                        @cancel="logToDelete = null"
                    />
                </div>
            `
        };

        // --- Vue Router Setup ---
        const routes = [
            { path: '/', component: ProjectDashboard },
            { path: '/project/:id', component: AssemblyHub, props: true },
            { path: '/video/:id', component: LoggingStation, props: true },
            { path: '/:pathMatch(.*)*', redirect: '/' } // Catch all redirect to home
        ];

        const router = createRouter({
            history: createWebHashHistory(),
            routes,
        });

        // --- Vue App Initialization ---
        const app = createApp({
            components: { ToastNotifications },
            setup() {
                onMounted(() => {
                    if (!('showOpenFilePicker' in window)) {
                        toastStore.addToast('File System Access API not fully supported. Video import may be limited.', 'info', 7000);
                    }
                     if (!('indexedDB' in window)) {
                        toastStore.addToast('IndexedDB not supported. Application data cannot be saved.', 'error', 10000);
                    }
                });
            }
        });
        app.use(router);
        app.mount('#app');

    </script>
</body>
</html>
