<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LogReel</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script> // Tailwind Config
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        stone: {
                            950: '#0c0a09',
                            900: '#1c1917',
                            800: '#292524',
                            700: '#44403c',
                            600: '#57534e',
                            500: '#78716c',
                            400: '#a8a29e',
                            300: '#d6d3d1',
                            200: '#e7e5e4',
                        },
                        indigo: {
                            600: '#4f46e5',
                            700: '#4338ca',
                            500: '#6366f1'
                        }
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- focus-trap -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/focus-trap/7.5.4/focus-trap.min.js"></script>

    <style type="text/tailwindcss">
        @layer base {
            html {
                font-family: 'Inter', sans-serif;
            }
            body {
                @apply bg-stone-950 text-stone-200 antialiased;
            }
            /* Custom scrollbar */
            ::-webkit-scrollbar {
                width: 8px;
                height: 8px;
            }
            ::-webkit-scrollbar-track {
                @apply bg-stone-800;
            }
            ::-webkit-scrollbar-thumb {
                @apply bg-stone-600 rounded-full;
            }
            ::-webkit-scrollbar-thumb:hover {
                @apply bg-stone-500;
            }
            /* Consistent focus outline for non-input elements */
            *:focus-visible:not(.input-field):not(.btn) { /* Exclude elements that have their own ring focus */
                outline: 2px solid theme('colors.indigo.500');
                outline-offset: 2px;
                border-radius: theme('borderRadius.md'); /* Optional: match border radius */
            }
             /* Remove default outline for elements styled with ring utilities */
            .input-field:focus, .btn:focus {
                 outline: none;
            }
        }
        .btn {
            @apply px-4 py-2 rounded-md font-semibold focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-stone-950 transition-colors duration-150 flex items-center justify-center gap-2;
        }
        .btn-primary {
            @apply bg-indigo-600 text-white hover:bg-indigo-700 focus:ring-indigo-500;
        }
        .btn-secondary {
            @apply bg-stone-700 text-stone-200 hover:bg-stone-600 focus:ring-stone-500;
        }
        .btn-sm {
             @apply px-2 py-1 text-xs;
        }
        .card {
            @apply bg-stone-900 border border-stone-800 rounded-lg shadow-md;
        }
        .input-field {
            @apply bg-stone-800 border border-stone-700 text-stone-200 placeholder-stone-500 text-sm rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 block w-full p-2.5;
        }
        .modal-overlay {
            @apply fixed inset-0 bg-black/70 flex items-center justify-center p-4 z-40;
        }
        .modal-content {
            @apply bg-stone-900 p-6 rounded-lg shadow-xl w-full z-50;
        }
        /* Transitions */
        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.3s ease;
        }
        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }
        .slide-up-enter-active, .slide-up-leave-active {
            transition: all 0.3s ease-out;
        }
        .slide-up-enter-from, .slide-up-leave-to {
            transform: translateY(20px);
            opacity: 0;
        }
    </style>
</head>
<body class="bg-stone-950 text-stone-200">
    <div id="app" class="min-h-screen flex flex-col">
        <noscript>
            <div style="color: white; padding: 20px; text-align: center;">
                <h1>JavaScript is required for LogReel to work.</h1>
                <p>Please enable JavaScript in your browser settings.</p>
            </div>
        </noscript>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/dexie@3/dist/dexie.js"></script>

    <script type="module">
        // --- GLOBAL ERROR HANDLER ---
        window.addEventListener('error', function (event) {
            console.error('GLOBAL UNCAUGHT ERROR:', event.message, 'at', event.filename, ':', event.lineno, event.error);
            const appDiv = document.getElementById('app');
            if (appDiv && !document.querySelector('.critical-error-display')) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'critical-error-display';
                errorDiv.style.cssText = 'color: red; background-color: black; padding: 20px; border: 2px solid red; position: fixed; top: 10px; left: 10px; right: 10px; z-index: 9999; font-size: 12px; white-space: pre-wrap; word-break: break-all;';
                errorDiv.innerHTML = `
                    <h2>Critical Application Error!</h2>
                    <p>LogReel could not start. Please check the browser console for details.</p>
                    <p><strong>Error:</strong> ${event.message}</p>
                    <p><strong>File:</strong> ${event.filename}</p>
                    <p><strong>Line:</strong> ${event.lineno}</p>
                    ${event.error && event.error.stack ? `<p><strong>Stack:</strong><br>${event.error.stack}</p>` : ''}
                `;
                if (document.body) document.body.prepend(errorDiv);
            }
        });
        window.addEventListener('unhandledrejection', function (event) {
            console.error('GLOBAL UNHANDLED PROMISE REJECTION:', event.reason);
             const appDiv = document.getElementById('app');
            if (appDiv && !document.querySelector('.critical-error-display')) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'critical-error-display';
                errorDiv.style.cssText = 'color: orange; background-color: black; padding: 20px; border: 2px solid orange; position: fixed; top: 10px; left: 10px; right: 10px; z-index: 9999; font-size: 12px; white-space: pre-wrap; word-break: break-all;';
                errorDiv.innerHTML = `<h2>Unhandled Promise Rejection!</h2><p>${event.reason.message || event.reason}</p><pre>${event.reason.stack || ''}</pre>`;
                if (document.body) document.body.prepend(errorDiv);
            }
        });
        // --- END GLOBAL ERROR HANDLER ---

        try {
            const { createApp, ref, reactive, computed, onMounted, onUnmounted, watch, nextTick } = Vue;

            const db = new Dexie('LogReelDB');
            db.version(1).stores({
                projects: '++id, name, createdAt',
                videos: '++id, projectId, fileName, important, createdAt, fileHandle', // Storing fileHandle
                logs: '++id, videoId, projectId, markIn, &keywords, createdAt' // Added projectId for easier filtering, compound index example for keywords
            });

            const App = {
                setup() {
                    let createFocusTrap;
                    // Check if focus-trap is loaded
                    if (window.focusTrap && typeof window.focusTrap.createFocusTrap === 'function') {
                        createFocusTrap = window.focusTrap.createFocusTrap;
                    } else {
                        console.error("FocusTrap library not found or createFocusTrap is not a function on window.focusTrap! Modals will not trap focus.");
                        // Provide a dummy implementation if focus-trap is not available
                        createFocusTrap = () => ({ activate: () => {}, deactivate: () => {} });
                    }

                    // --- App State ---
                    const currentScreen = ref('projectDashboard'); // projectDashboard, assemblyHub, loggingStation
                    const currentProjectId = ref(null);
                    const currentVideoId = ref(null);

                    const projects = ref([]);
                    const videosInCurrentProject = ref([]);
                    const logsInCurrentProject = ref([]); // All logs for the current project (Assembly Hub)
                    const logsForCurrentVideo = ref([]);  // Logs for the specific video in Logging Station

                    const isLoading = ref(false);
                    const toastMessages = ref([]);

                    // --- Toast Notifications ---
                    function showToast(text, type = 'success', duration = 3000) {
                        const id = Date.now() + Math.random();
                        toastMessages.value.push({ id, text, type });
                        setTimeout(() => {
                            toastMessages.value = toastMessages.value.filter(t => t.id !== id);
                        }, duration);
                    }

                    // --- Utility Functions ---
                    function formatTime(totalSeconds, showMillis = false) {
                        if (isNaN(totalSeconds) || totalSeconds < 0) return showMillis ? '00:00:00.000' : '00:00:00';
                        const hours = Math.floor(totalSeconds / 3600);
                        const minutes = Math.floor((totalSeconds % 3600) / 60);
                        const seconds = Math.floor(totalSeconds % 60);
                        const milliseconds = Math.floor((totalSeconds - Math.floor(totalSeconds)) * 1000);
                        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}${showMillis ? '.' + String(milliseconds).padStart(3, '0') : ''}`;
                    }

                    async function verifyFilePermission(fileHandle, withWrite = false) {
                        if (!fileHandle || typeof fileHandle.queryPermission !== 'function') {
                            console.warn("Invalid fileHandle provided to verifyFilePermission", fileHandle);
                            showToast("File handle issue. Re-select the file/folder.", "error", 5000);
                            return false;
                        }
                        const opts = withWrite ? { mode: 'readwrite' } : { mode: 'read' };
                        try {
                            // Check if permission was already granted.
                            if (await fileHandle.queryPermission(opts) === 'granted') {
                                return true;
                            }
                            // Request permission.
                            if (await fileHandle.requestPermission(opts) === 'granted') {
                                return true;
                            }
                            // Permission was not granted.
                            return false;
                        } catch (err) {
                            console.error("Error verifying/requesting file permission:", err);
                            showToast("Error accessing file. Permission might have been revoked.", "error", 5000);
                            return false;
                        }
                    }


                    // --- Navigation ---
                    function navigateTo(screen, projectId = null, videoId = null) {
                        currentProjectId.value = projectId;
                        currentVideoId.value = videoId;

                        // Reset states for screens not being navigated to
                        if (screen !== 'assemblyHub') {
                            videosInCurrentProject.value = [];
                            logsInCurrentProject.value = [];
                            assemblySearchQuery.value = ''; // Reset search
                        }
                        if (screen !== 'loggingStation') {
                            logsForCurrentVideo.value = [];
                            if (videoSrc.value) URL.revokeObjectURL(videoSrc.value);
                            videoSrc.value = '';
                            markInTime.value = null;
                            markOutTime.value = null;
                            resetLogForm();
                        }
                        currentScreen.value = screen;
                    }

                    // --- Project Dashboard ---
                    const newProjectName = ref('');
                    const showNewProjectModal = ref(false);
                    let newProjectModalFocusTrap = null;
                    const newProjectModalElement = ref(null); // Ref for the modal DOM element

                    watch(showNewProjectModal, (isShown) => {
                        nextTick(() => { // Ensure DOM is updated before trying to access the element
                            if (isShown && newProjectModalElement.value) {
                                if (!newProjectModalFocusTrap) {
                                     if (typeof createFocusTrap !== 'function') {
                                        console.error("createFocusTrap is not a function. Modal focus trap will not work.");
                                        return;
                                    }
                                    newProjectModalFocusTrap = createFocusTrap(newProjectModalElement.value, {
                                        onDeactivate: () => {
                                            // Ensure the modal is hidden if focus trap is deactivated externally (e.g., Escape key)
                                            showNewProjectModal.value = false;
                                        },
                                        initialFocus: () => newProjectModalElement.value.querySelector('input[type="text"]') || undefined,
                                        escapeDeactivates: true, // Allow Escape key to close modal
                                    });
                                }
                                newProjectModalFocusTrap.activate();
                                // Optional: explicitly focus the input after activation
                                const inputEl = newProjectModalElement.value?.querySelector('input[type="text"]');
                                inputEl?.focus();
                            } else if (!isShown && newProjectModalFocusTrap) {
                                newProjectModalFocusTrap.deactivate();
                            }
                        });
                    });


                    async function loadProjects() {
                        isLoading.value = true;
                        try {
                            const projectList = await db.projects.orderBy('createdAt').reverse().toArray();
                            // Get video counts for each project
                            for (const proj of projectList) {
                                proj.videoCount = await db.videos.where('projectId').equals(proj.id).count();
                            }
                            projects.value = projectList;
                        } catch (error) {
                            console.error("Critical Error loading projects:", error);
                            showToast(`CRITICAL: Failed to load projects. ${error.message}`, "error", 10000);
                        } finally {
                            isLoading.value = false;
                        }
                    }

                    async function createProject() {
                        if (!newProjectName.value.trim()) {
                            showToast("Project name cannot be empty.", "error");
                            return;
                        }
                        isLoading.value = true;
                        try {
                            await db.projects.add({
                                name: newProjectName.value.trim(),
                                createdAt: new Date()
                            });
                            showToast("Project created successfully!", "success");
                            newProjectName.value = '';
                            showNewProjectModal.value = false; // This will trigger the watch to deactivate focus trap
                            await loadProjects();
                        } catch (error) {
                            console.error("Error creating project:", error);
                            showToast(`Failed to create project: ${error.message}`, "error");
                        } finally {
                            isLoading.value = false;
                        }
                    }

                    function openProject(projectId) {
                        navigateTo('assemblyHub', projectId);
                    }

                    // --- Assembly Hub ---
                    const currentProject = computed(() => projects.value.find(p => p.id === currentProjectId.value));
                    const assemblySearchQuery = ref('');

                    async function loadAssemblyHubData() {
                        if (!currentProjectId.value) return;
                        isLoading.value = true;
                        console.log(`Attempting to load Assembly Hub data for projectId: ${currentProjectId.value}`);
                        try {
                            console.log("Fetching videos from DB...");
                            const projectVideos = await db.videos
                                .where('projectId').equals(currentProjectId.value)
                                .orderBy('createdAt').toArray(); // Sort by creation or name
                            console.log("Videos fetched:", projectVideos);
                            videosInCurrentProject.value = projectVideos;

                            console.log("Fetching logs from DB for the entire project...");
                            const projectLogs = await db.logs
                                .where('projectId').equals(currentProjectId.value)
                                .toArray();
                            console.log("Logs fetched:", projectLogs);
                            logsInCurrentProject.value = projectLogs; // Store all logs for current project
                            console.log("Assembly Hub data loaded successfully.");

                        } catch (error) {
                            console.error("Error loading assembly hub data:", error.name, error.message, error.stack, error);
                            showToast("Failed to load project data. Please try again or check console.", "error", 7000);
                            navigateTo('projectDashboard'); // Fallback to dashboard
                        } finally {
                            isLoading.value = false;
                        }
                    }


                    watch(currentProjectId, (newVal) => {
                        if (newVal && currentScreen.value === 'assemblyHub') {
                            loadAssemblyHubData();
                        }
                    });

                    const filteredVideos = computed(() => {
                        if (!assemblySearchQuery.value.trim()) {
                            return videosInCurrentProject.value;
                        }
                        const query = assemblySearchQuery.value.toLowerCase().trim();
                        return videosInCurrentProject.value.filter(video => {
                            // Check video name
                            if (video.fileName.toLowerCase().includes(query)) return true;
                            // Check logs associated with this video
                            const videoLogs = logsInCurrentProject.value.filter(log => log.videoId === video.id);
                            for (const log of videoLogs) {
                                if (log.notes && log.notes.toLowerCase().includes(query)) return true;
                                if (log.keywords && log.keywords.some(k => k.toLowerCase().includes(query))) return true;
                            }
                            return false;
                        });
                    });

                    async function addVideosToProject() {
                        if (!window.showOpenFilePicker) {
                            showToast("File System Access API is not supported in your browser/context. Try a modern browser like Chrome or Edge.", "error", 6000);
                            return;
                        }
                        isLoading.value = true;
                        try {
                            const handles = await window.showOpenFilePicker({
                                multiple: true,
                                types: [{ description: 'Video Files', accept: { 'video/*': ['.mp4', '.mov', '.webm', '.mkv', '.avi', '.mpg', '.mpeg', '.wmv', '.flv'] } }]
                            });

                            let addedCount = 0;
                            for (const handle of handles) {
                                 // Verify permission for each handle before proceeding
                                 if (!(await verifyFilePermission(handle))) {
                                    showToast(`Permission denied for ${handle.name}. Skipping.`, "info");
                                    continue;
                                }
                                const file = await handle.getFile(); // Get file to check details like name
                                const existingVideo = await db.videos.where({ projectId: currentProjectId.value, fileName: file.name }).first();
                                if (existingVideo) {
                                    showToast(`Video "${file.name}" already exists in this project. Skipping.`, "info");
                                    continue;
                                }

                                await db.videos.add({
                                    projectId: currentProjectId.value,
                                    fileName: file.name,
                                    fileType: file.type, // Store file type
                                    fileSize: file.size, // Store file size
                                    fileHandle: handle, // Store the handle itself
                                    important: false,
                                    createdAt: new Date()
                                });
                                addedCount++;
                            }
                            if (addedCount > 0) showToast(`${addedCount} video(s) added successfully.`, "success");
                            if (addedCount !== handles.length && handles.length > 0) showToast(`${handles.length - addedCount} video(s) were skipped (e.g., duplicates or permission issues).`, "info");

                            await loadAssemblyHubData(); // Refresh video list
                        } catch (error) {
                            if (error.name === 'AbortError') {
                                console.log("File picker aborted by user."); // Not an error to show toast for
                            } else {
                                console.error("Error adding videos:", error);
                                showToast(`Error adding videos: ${error.message}`, "error");
                            }
                        } finally {
                            isLoading.value = false;
                        }
                    }

                    async function toggleVideoImportant(video) {
                        isLoading.value = true;
                        try {
                            const newImportance = !video.important;
                            await db.videos.update(video.id, { important: newImportance });
                            // Update local array for immediate UI reflection
                            const videoInArray = videosInCurrentProject.value.find(v => v.id === video.id);
                            if (videoInArray) videoInArray.important = newImportance;
                            showToast(`Video marked ${newImportance ? 'important' : 'not important'}.`, "success");
                        } catch (error) {
                            console.error("Error updating video importance:", error);
                            showToast("Failed to update video status.", "error");
                        } finally {
                            isLoading.value = false;
                        }
                    }

                    function openLoggingStation(video) {
                        navigateTo('loggingStation', video.projectId, video.id);
                    }

                    // For expanding logs list in Assembly Hub
                    const expandedVideoLogs = ref({}); // Stores videoId: true/false
                    function toggleViewLogs(videoId) {
                        expandedVideoLogs.value[videoId] = !expandedVideoLogs.value[videoId];
                    }
                    function getLogsForVideoCard(videoId) { // Used in template
                        return logsInCurrentProject.value.filter(log => log.videoId === videoId)
                                                   .sort((a,b) => a.markIn - b.markIn);
                    }
                    function hasLogs(videoId){ // Used in template
                        return logsInCurrentProject.value.some(log => log.videoId === videoId);
                    }


                    // --- Logging Station ---
                    const currentVideoDetails = ref(null); // Full video object from DB
                    const videoPlayerRef = ref(null); // Ref for the <video> element
                    const videoSrc = ref(''); // Object URL for the video
                    const currentTime = ref(0);
                    const duration = ref(0);
                    const isPlaying = ref(false);
                    const markInTime = ref(null);
                    const markOutTime = ref(null);

                    const logForm = reactive({ notes: '', rating: 0, keywords: [], newKeyword: '' });

                    watch(currentVideoId, async (newVal) => {
                        if (newVal && currentScreen.value === 'loggingStation') {
                            await loadLoggingStationData();
                        }
                    });

                    async function loadLoggingStationData() {
                        if (!currentVideoId.value) return;
                        isLoading.value = true;
                        try {
                            const videoData = await db.videos.get(currentVideoId.value);
                            if (!videoData) {
                                showToast("Video not found. It might have been deleted.", "error");
                                navigateTo('assemblyHub', currentProjectId.value || undefined);
                                return;
                            }
                            currentVideoDetails.value = videoData;

                            // Crucial: Get file from stored handle and set src
                            if (videoData.fileHandle) {
                               if (await verifyFilePermission(videoData.fileHandle)) {
                                    const file = await videoData.fileHandle.getFile();
                                    if (videoSrc.value) URL.revokeObjectURL(videoSrc.value); // Clean up old object URL
                                    videoSrc.value = URL.createObjectURL(file);
                               } else {
                                   showToast("Permission denied for video file. Re-add or re-select if prompted.", "error", 5000);
                                   navigateTo('assemblyHub', currentProjectId.value); return;
                               }
                            } else {
                                showToast("Video file handle missing. This video may be corrupted or was not added correctly. Please re-add it.", "error", 5000);
                                navigateTo('assemblyHub', currentProjectId.value); return;
                            }

                            // Load logs specific to this video
                            const videoLogs = await db.logs.where('videoId').equals(currentVideoId.value)
                                                      .orderBy('markIn').toArray(); // Sort by markIn time
                            logsForCurrentVideo.value = videoLogs;

                        } catch (error) {
                            console.error("Error loading logging station data:", error);
                            showToast("Failed to load video or its logs. Check console for details.", "error");
                            navigateTo('assemblyHub', currentProjectId.value); // Go back if error
                        } finally {
                            isLoading.value = false;
                        }
                    }

                    // Video player event handlers
                    function handleTimeUpdate(event) { currentTime.value = event.target.currentTime; }
                    function handleLoadedMetadata(event) {
                        duration.value = event.target.duration;
                        markInTime.value = null; markOutTime.value = null; // Reset marks when new video loads
                    }
                    function handlePlay() { isPlaying.value = true; }
                    function handlePause() { isPlaying.value = false; }
                    function togglePlayPause() { videoPlayerRef.value?.paused ? videoPlayerRef.value?.play() : videoPlayerRef.value?.pause(); }
                    function seekVideo(time) { if(videoPlayerRef.value) videoPlayerRef.value.currentTime = time; }
                    function onTimelineClick(event) {
                        if (!videoPlayerRef.value || !duration.value) return;
                        const timeline = event.currentTarget;
                        const rect = timeline.getBoundingClientRect();
                        const clickX = event.clientX - rect.left;
                        const percentage = Math.max(0, Math.min(1, clickX / rect.width)); // Clamp between 0 and 1
                        seekVideo(duration.value * percentage);
                    }

                    const progressPercent = computed(() => duration.value ? (currentTime.value / duration.value) * 100 : 0);
                    const markInRangeStyle = computed(() => {
                        if (markInTime.value === null || markOutTime.value === null || !duration.value || markOutTime.value <= markInTime.value) return { display: 'none' };
                        const startPercent = (markInTime.value / duration.value) * 100;
                        const widthPercent = ((markOutTime.value - markInTime.value) / duration.value) * 100;
                        return { left: `${startPercent}%`, width: `${widthPercent}%`, display: 'block' };
                    });

                    function setMarkIn() { if(videoPlayerRef.value) markInTime.value = videoPlayerRef.value.currentTime; }
                    function setMarkOut() { if(videoPlayerRef.value) markOutTime.value = videoPlayerRef.value.currentTime; }

                    function addKeyword() {
                        const newKeyword = logForm.newKeyword.trim().toLowerCase();
                        if (newKeyword && !logForm.keywords.includes(newKeyword)) {
                            logForm.keywords.push(newKeyword);
                        }
                        logForm.newKeyword = ''; // Clear input
                    }
                    function removeKeyword(keywordToRemove) {
                        logForm.keywords = logForm.keywords.filter(k => k !== keywordToRemove);
                    }
                    function resetLogForm() {
                        logForm.notes = ''; logForm.rating = 0; logForm.keywords = []; logForm.newKeyword = '';
                        // Optionally reset markIn/markOut too, or leave them for quick re-logging of same segment
                        // markInTime.value = null; markOutTime.value = null;
                    }

                    async function saveLog() {
                        if (markInTime.value === null || markOutTime.value === null) {
                            showToast("Please set both Mark In and Mark Out points.", "error"); return;
                        }
                        if (markInTime.value >= markOutTime.value) {
                            showToast("Mark Out time must be after Mark In time.", "error"); return;
                        }
                        if (!logForm.notes.trim() && logForm.keywords.length === 0 && logForm.rating === 0) {
                             showToast("Please add notes, keywords, or a rating to save a log.", "error"); return;
                        }
                        isLoading.value = true;
                        try {
                            const newLogData = {
                                videoId: currentVideoId.value, projectId: currentProjectId.value, // Store projectId for easier project-wide log ops
                                markIn: markInTime.value, markOut: markOutTime.value,
                                notes: logForm.notes.trim(), rating: logForm.rating,
                                keywords: [...logForm.keywords], // Clone array
                                createdAt: new Date()
                            };
                            const newLogId = await db.logs.add(newLogData);
                            showToast("Log saved successfully!", "success");

                            // Optimistically update local logs array
                            const newLogWithId = {...newLogData, id: newLogId };
                            logsForCurrentVideo.value.push(newLogWithId);
                            logsForCurrentVideo.value.sort((a,b) => a.markIn - b.markIn); // Re-sort

                            // Also update the project-wide logs in Assembly Hub's cache
                            logsInCurrentProject.value.push(newLogWithId);


                            resetLogForm();
                        } catch (error) {
                            console.error("Error saving log:", error);
                            showToast(`Failed to save log: ${error.message}`, "error");
                        } finally {
                            isLoading.value = false;
                        }
                    }

                    // Keyboard shortcuts for Logging Station
                    function handleKeydown(event) {
                        if (currentScreen.value !== 'loggingStation') return;
                        const activeElement = document.activeElement;
                        const isTyping = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable);

                        if (event.code === 'Space' && !isTyping) { event.preventDefault(); togglePlayPause(); }
                        else if (event.key.toLowerCase() === 'i' && !isTyping) { event.preventDefault(); setMarkIn(); }
                        else if (event.key.toLowerCase() === 'o' && !isTyping) { event.preventDefault(); setMarkOut(); }
                    }

                    // --- Play Selects Modal ---
                    const showPlaySelectsModal = ref(false);
                    const playSelectsVideoSrc = ref('');
                    const playSelectsLogs = ref([]); // Logs specifically for the selects player
                    const currentSelectIndex = ref(0);
                    const playSelectsPlayerRef = ref(null); // Ref for the selects <video> element
                    let playSelectsFocusTrapInstance = null;
                    const playSelectsModalElement = ref(null); // Ref for the modal DOM element

                    async function openPlaySelectsModal(video) { // Pass the whole video object
                        isLoading.value = true;
                        try {
                            // Filter logs for *this specific video* from the project-wide cache
                            const logs = logsInCurrentProject.value.filter(log => log.videoId === video.id)
                                                     .sort((a, b) => a.markIn - b.markIn);
                            if (logs.length === 0) {
                                showToast("No logs to play for this video.", "info"); return;
                            }
                            playSelectsLogs.value = logs;

                            // Video data might already be in `video` object if called from Assembly Hub
                            // Or fetch if needed (though `video.fileHandle` should be there)
                            const videoData = await db.videos.get(video.id); // Re-fetch to ensure fresh handle
                            if (!videoData || !videoData.fileHandle) {
                                showToast("Video data or file handle not found for Play Selects.", "error"); return;
                            }

                            if (await verifyFilePermission(videoData.fileHandle)) {
                                const file = await videoData.fileHandle.getFile();
                                if (playSelectsVideoSrc.value) URL.revokeObjectURL(playSelectsVideoSrc.value);
                                playSelectsVideoSrc.value = URL.createObjectURL(file);
                                currentSelectIndex.value = 0;
                                showPlaySelectsModal.value = true; // This will trigger the watch

                                nextTick(() => { // Ensure modal element is in DOM
                                    if (playSelectsModalElement.value) {
                                        if (!playSelectsFocusTrapInstance) {
                                            if (typeof createFocusTrap !== 'function') {
                                                console.error("createFocusTrap is not a function. PlaySelectsModal focus trap will not work.");
                                                return;
                                            }
                                            playSelectsFocusTrapInstance = createFocusTrap(playSelectsModalElement.value, {
                                                onDeactivate: () => {
                                                    // This ensures that if the trap is deactivated (e.g. by Escape), the modal closes
                                                    if (showPlaySelectsModal.value) closePlaySelectsModal();
                                                },
                                                initialFocus: () => playSelectsPlayerRef.value || undefined, // Focus video player
                                                escapeDeactivates: true,
                                            });
                                        }
                                        playSelectsFocusTrapInstance.activate();
                                    }
                                    // playCurrentSelectSegment() will be called by @loadeddata on video
                                });
                            } else {
                                showToast("Could not get permission to load video for Play Selects.", "error", 5000);
                            }
                        } catch (error) {
                            console.error("Error opening Play Selects:", error);
                            showToast(`Error preparing Play Selects: ${error.message}`, "error");
                        } finally {
                            isLoading.value = false;
                        }
                    }

                    function closePlaySelectsModal() {
                        if (!showPlaySelectsModal.value) return; // Prevent multiple calls if already closing

                        if (playSelectsPlayerRef.value) playSelectsPlayerRef.value.pause();
                        if (playSelectsVideoSrc.value) URL.revokeObjectURL(playSelectsVideoSrc.value);
                        playSelectsVideoSrc.value = '';
                        playSelectsLogs.value = []; // Clear logs
                        showPlaySelectsModal.value = false; // Triggers watch to deactivate trap

                        // Deactivation is now handled by the watch on showPlaySelectsModal
                        // and by the onDeactivate callback in createFocusTrap
                        if (playSelectsFocusTrapInstance) {
                            playSelectsFocusTrapInstance.deactivate(); // Explicitly call if needed
                            playSelectsFocusTrapInstance = null; // Clean up instance
                        }
                    }


                    function playCurrentSelectSegment() {
                        const player = playSelectsPlayerRef.value;
                        if (!player || playSelectsLogs.value.length === 0) return;

                        if (currentSelectIndex.value >= playSelectsLogs.value.length) {
                            showToast("All selects played.", "info");
                            player.pause(); // Ensure paused
                            return;
                        }

                        const currentLog = playSelectsLogs.value[currentSelectIndex.value];
                        player.currentTime = currentLog.markIn;
                        player.play().catch(e => console.error("Error playing select:", e));
                    }

                    function handlePlaySelectsTimeUpdate() {
                        const player = playSelectsPlayerRef.value;
                        if (!player || playSelectsLogs.value.length === 0 || currentSelectIndex.value >= playSelectsLogs.value.length || player.paused) return;

                        const currentLog = playSelectsLogs.value[currentSelectIndex.value];
                        if (player.currentTime >= currentLog.markOut) {
                            player.pause();
                            currentSelectIndex.value++;
                            // Small delay before playing next to allow UI to update and avoid race conditions
                            setTimeout(playCurrentSelectSegment, 100);
                        }
                    }
                    // This will be called once the video data is loaded for the Play Selects player
                    function handlePlaySelectsLoadedData(){
                        playCurrentSelectSegment();
                    }


                    // --- Lifecycle Hooks ---
                    onMounted(async () => {
                        try {
                            await loadProjects();
                            // Attempt to make storage persistent
                            if (navigator.storage && navigator.storage.persist) {
                                if (!await navigator.storage.persisted()) { // Check if already persisted
                                    const result = await navigator.storage.persist();
                                    if(result) {
                                        console.log("Storage successfully persisted.");
                                    } else {
                                        showToast("Offline storage may not be persistent. Your browser might clear data.", "info", 7000);
                                    }
                                } else {
                                     console.log("Storage was already persistent.");
                                }
                            } else {
                                showToast("Persistent storage API not available from this context (e.g., private browsing, or older browser).", "warning", 7000);
                            }
                        } catch (e) {
                            console.error("LogReel: CRITICAL ERROR IN ONMOUNTED", e);
                            showToast(`CRITICAL Mount Error: ${e.message}. Application might not work correctly. Check console.`, "error", 15000);
                        }
                        window.addEventListener('keydown', handleKeydown);
                    });

                    onUnmounted(() => {
                        window.removeEventListener('keydown', handleKeydown);
                        // Clean up any object URLs to prevent memory leaks
                        if (videoSrc.value) URL.revokeObjectURL(videoSrc.value);
                        if (playSelectsVideoSrc.value) URL.revokeObjectURL(playSelectsVideoSrc.value);
                    });

                    return {
                        // State
                        currentScreen, currentProjectId, currentVideoId, isLoading, toastMessages,
                        projects, videosInCurrentProject, logsInCurrentProject, logsForCurrentVideo,
                        // Project Dashboard
                        newProjectName, showNewProjectModal, newProjectModalElement,
                        // Assembly Hub
                        currentProject, assemblySearchQuery, filteredVideos, expandedVideoLogs,
                        // Logging Station
                        currentVideoDetails, videoPlayerRef, videoSrc, currentTime, duration, isPlaying,
                        markInTime, markOutTime, progressPercent, markInRangeStyle,
                        logForm,
                        // Play Selects Modal
                        showPlaySelectsModal, playSelectsVideoSrc, playSelectsLogs, currentSelectIndex, playSelectsPlayerRef, playSelectsModalElement,
                        // Methods
                        showToast, formatTime, navigateTo,
                        loadProjects, createProject, openProject,
                        loadAssemblyHubData, addVideosToProject, toggleVideoImportant, openLoggingStation, toggleViewLogs, getLogsForVideoCard, hasLogs,
                        loadLoggingStationData, handleTimeUpdate, handleLoadedMetadata, handlePlay, handlePause, togglePlayPause, seekVideo, onTimelineClick,
                        setMarkIn, setMarkOut, addKeyword, removeKeyword, saveLog, resetLogForm,
                        openPlaySelectsModal, closePlaySelectsModal, handlePlaySelectsTimeUpdate, handlePlaySelectsLoadedData,
                    };
                },
                template: `
                    <!-- Toast Notifications Container -->
                    <div aria-live="assertive" class="fixed inset-0 flex flex-col items-end px-4 py-6 pointer-events-none sm:p-6 sm:items-end z-[100]">
                        <TransitionGroup name="fade" tag="div" class="w-full max-w-sm space-y-2">
                            <div v-for="toast in toastMessages" :key="toast.id"
                                 class="pointer-events-auto w-full max-w-sm overflow-hidden rounded-lg shadow-lg ring-1 ring-black ring-opacity-5"
                                 :class="{ 'bg-green-600 text-white': toast.type === 'success', 'bg-red-600 text-white': toast.type === 'error', 'bg-blue-600 text-white': toast.type === 'info', 'bg-yellow-500 text-black': toast.type === 'warning' }">
                                <div class="p-4">
                                    <p class="text-sm font-medium">{{ toast.text }}</p>
                                </div>
                            </div>
                        </TransitionGroup>
                    </div>

                    <!-- Global Loading Indicator -->
                    <div v-if="isLoading" class="fixed inset-0 bg-stone-950/80 flex items-center justify-center z-[99]">
                        <svg class="animate-spin h-10 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                    </div>

                    <!-- Screen: Project Dashboard -->
                    <div v-if="currentScreen === 'projectDashboard'" class="p-4 sm:p-6 lg:p-8 flex-grow">
                        <header class="flex items-center justify-between mb-8">
                            <h1 class="text-3xl font-bold text-stone-100">LogReel</h1>
                            <button @click="showNewProjectModal = true" class="btn btn-primary">
                                <i class="ph ph-plus-circle text-xl"></i>
                                <span>New Project</span>
                            </button>
                        </header>

                        <div v-if="projects.length === 0 && !isLoading" class="text-center text-stone-400 py-10">
                            <i class="ph ph-folder-notch-open text-6xl mb-4"></i>
                            <p class="text-xl">No projects yet.</p>
                            <p>Click "New Project" to get started.</p>
                        </div>

                        <TransitionGroup v-else name="slide-up" tag="div" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                            <div v-for="project in projects" :key="project.id" @click="openProject(project.id)" tabindex="0" @keydown.enter="openProject(project.id)"
                                 class="card p-6 cursor-pointer hover:border-indigo-500 transition-colors group">
                                <h2 class="text-xl font-semibold text-stone-100 mb-2 truncate group-hover:text-indigo-400" :title="project.name">{{ project.name }}</h2>
                                <p class="text-sm text-stone-400">{{ project.videoCount }} video{{ project.videoCount === 1 ? '' : 's' }}</p>
                                <p class="text-xs text-stone-500 mt-3">Created: {{ new Date(project.createdAt).toLocaleDateString() }}</p>
                            </div>
                        </TransitionGroup>

                        <!-- New Project Modal -->
                        <Transition name="fade">
                            <div v-if="showNewProjectModal" class="modal-overlay" @click.self="showNewProjectModal = false" role="dialog" aria-modal="true" aria-labelledby="newProjectModalTitle">
                                <div ref="newProjectModalElement" class="modal-content w-full max-w-md">
                                    <h3 id="newProjectModalTitle" class="text-xl font-semibold mb-4 text-stone-100">Create New Project</h3>
                                    <form @submit.prevent="createProject">
                                        <label for="newProjectNameInput" class="sr-only">Project Name</label>
                                        <input id="newProjectNameInput" type="text" v-model="newProjectName" placeholder="Project Name" class="input-field mb-4" required>
                                        <div class="flex justify-end gap-3">
                                            <button type="button" @click="showNewProjectModal = false" class="btn btn-secondary">Cancel</button>
                                            <button type="submit" class="btn btn-primary" :disabled="!newProjectName.trim()">Create</button>
                                        </div>
                                    </form>
                                </div>
                            </div>
                        </Transition>
                    </div>

                    <!-- Screen: Assembly Hub -->
                    <div v-if="currentScreen === 'assemblyHub' && currentProject" class="flex flex-col h-screen">
                        <header class="p-4 sm:p-6 border-b border-stone-800 shrink-0">
                            <button @click="navigateTo('projectDashboard')" class="btn btn-secondary mb-4 text-sm">
                                <i class="ph ph-arrow-left text-lg"></i>
                                <span>Back to Projects</span>
                            </button>
                            <h1 class="text-2xl sm:text-3xl font-bold text-stone-100 mb-1 truncate" :title="currentProject.name">{{ currentProject.name }}</h1>
                        </header>

                        <div class="sticky top-0 bg-stone-950/80 backdrop-blur-md z-10 p-4 sm:p-6 border-b border-stone-800 shrink-0">
                            <div class="flex flex-col sm:flex-row items-center gap-4">
                                <div class="relative flex-grow w-full sm:w-auto">
                                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                        <i class="ph ph-magnifying-glass text-stone-400"></i>
                                    </div>
                                    <label for="assemblySearchInput" class="sr-only">Search videos, notes, or keywords within this project</label>
                                    <input id="assemblySearchInput" type="search" v-model="assemblySearchQuery" placeholder="Search videos, notes, keywords..." class="input-field pl-10 w-full">
                                </div>
                                <button @click="addVideosToProject" class="btn btn-primary w-full sm:w-auto shrink-0">
                                    <i class="ph ph-plus-circle text-xl"></i>
                                    <span>Add Videos</span>
                                </button>
                            </div>
                        </div>

                        <div v-if="filteredVideos.length === 0 && !isLoading" class="text-center text-stone-400 py-10 flex-grow flex flex-col items-center justify-center">
                            <i class="ph ph-video-camera-slash text-6xl mb-4"></i>
                            <p class="text-xl">No videos in this project{{ assemblySearchQuery ? ' match your search' : '' }}.</p>
                            <p v-if="!assemblySearchQuery">Click "Add Videos" to import footage.</p>
                        </div>

                        <main v-else class="flex-grow overflow-y-auto p-4 sm:p-6">
                            <TransitionGroup name="slide-up" tag="div" class="space-y-4">
                                <div v-for="(video, index) in filteredVideos" :key="video.id" class="card">
                                    <div class="p-4 sm:p-5 flex flex-col sm:flex-row sm:items-center gap-4">
                                        <div class="shrink-0 text-xl font-semibold text-stone-400 w-8 text-center hidden sm:block">{{ index + 1 }}.</div>
                                        <div class="shrink-0 w-32 h-20 bg-stone-800 rounded flex items-center justify-center aspect-video">
                                            <!-- Basic thumbnail placeholder -->
                                            <i class="ph ph-film-strip text-4xl text-stone-500"></i>
                                        </div>
                                        <div class="flex-grow min-w-0">
                                            <h3 class="text-lg font-medium text-stone-100 truncate" :title="video.fileName">{{ video.fileName }}</h3>
                                            <p class="text-xs text-stone-500">{{ (video.fileSize / (1024*1024)).toFixed(2) }} MB | {{ video.fileType || 'N/A' }}</p>
                                        </div>
                                        <div class="flex items-center gap-2 shrink-0 flex-wrap sm:flex-nowrap justify-start sm:justify-end mt-3 sm:mt-0">
                                            <button @click="toggleVideoImportant(video)" :title="video.important ? 'Mark as not important' : 'Mark as important'"
                                                    class="p-2 rounded-full hover:bg-stone-700 transition-colors focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-2 focus-visible:ring-offset-stone-900">
                                                <i class="text-xl" :class="video.important ? 'ph-fill ph-star text-yellow-400' : 'ph ph-star text-stone-500'"></i>
                                            </button>
                                            <button @click="openPlaySelectsModal(video)"
                                                    :disabled="!hasLogs(video.id)"
                                                    class="btn btn-secondary text-sm"
                                                    :class="{ 'opacity-50 cursor-not-allowed': !hasLogs(video.id) }">
                                                <i class="ph ph-play"></i><span>Play Selects</span>
                                            </button>
                                            <button @click="openLoggingStation(video)" class="btn btn-primary text-sm">
                                                <i class="ph ph-note-pencil"></i><span>Log</span>
                                            </button>
                                        </div>
                                    </div>
                                    <div v-if="hasLogs(video.id)" class="border-t border-stone-800 px-4 sm:px-5 py-2">
                                        <button @click="toggleViewLogs(video.id)" class="text-sm text-indigo-400 hover:text-indigo-300 font-medium flex items-center gap-1 w-full justify-between">
                                            <span>{{ expandedVideoLogs[video.id] ? 'Hide Logs' : 'View Logs' }} ({{ getLogsForVideoCard(video.id).length }})</span>
                                            <i class="ph transition-transform" :class="expandedVideoLogs[video.id] ? 'ph-caret-up' : 'ph-caret-down'"></i>
                                        </button>
                                    </div>
                                    <Transition name="fade">
                                    <div v-if="expandedVideoLogs[video.id] && hasLogs(video.id)" class="border-t border-stone-800 p-4 sm:p-5 bg-stone-950/30 max-h-60 overflow-y-auto">
                                        <ul class="space-y-3">
                                            <li v-for="log in getLogsForVideoCard(video.id)" :key="log.id" class="text-sm">
                                                <div class="flex justify-between items-center">
                                                    <span class="font-semibold text-stone-300">{{ formatTime(log.markIn) }} - {{ formatTime(log.markOut) }}</span>
                                                    <span class="ml-2 flex">
                                                        <i v-for="s_idx in 5" :key="s_idx" class="ph-star text-xs" :class="s_idx <= log.rating ? 'ph-fill text-yellow-400' : 'text-stone-600'"></i>
                                                    </span>
                                                </div>
                                                <p class="text-stone-400 whitespace-pre-wrap my-1 break-words">{{ log.notes || 'No notes.' }}</p>
                                                <div v-if="log.keywords && log.keywords.length > 0" class="mt-1">
                                                    <span v-for="kw in log.keywords" :key="kw" class="inline-block bg-indigo-500/20 text-indigo-300 text-xs px-2 py-0.5 rounded-full mr-1 mb-1">{{ kw }}</span>
                                                </div>
                                            </li>
                                        </ul>
                                    </div>
                                    </Transition>
                                </div>
                            </TransitionGroup>
                        </main>
                    </div>

                    <!-- Screen: Logging Station -->
                    <div v-if="currentScreen === 'loggingStation' && currentVideoDetails" class="flex flex-col h-screen">
                        <header class="p-4 sm:p-6 border-b border-stone-800 shrink-0">
                            <button @click="navigateTo('assemblyHub', currentProjectId)" class="btn btn-secondary mb-4 text-sm">
                                <i class="ph ph-arrow-left text-lg"></i>
                                <span>Back to Project</span>
                            </button>
                            <h1 class="text-2xl sm:text-3xl font-bold text-stone-100 truncate" :title="currentVideoDetails.fileName">{{ currentVideoDetails.fileName }}</h1>
                        </header>

                        <div class="sticky top-0 bg-stone-950 z-10 p-4 sm:p-6 border-b border-stone-800 shrink-0">
                            <video ref="videoPlayerRef" :src="videoSrc" @timeupdate="handleTimeUpdate" @loadedmetadata="handleLoadedMetadata" @play="handlePlay" @pause="handlePause" @ended="isPlaying = false"
                                   controls class="w-full max-h-[calc(40vh-theme(space.12))] sm:max-h-[calc(50vh-theme(space.12))] rounded-md bg-black mb-3 aspect-video"></video>

                            <div @click="onTimelineClick" class="relative h-3 bg-stone-700 rounded-full cursor-pointer mb-3 group" role="slider" :aria-valuenow="currentTime" :aria-valuemin="0" :aria-valuemax="duration" aria-label="Video timeline">
                                <div class="absolute h-full bg-indigo-300/50 rounded-full" :style="markInRangeStyle" aria-hidden="true"></div>
                                <div class="absolute h-full bg-indigo-500 rounded-full" :style="{ width: progressPercent + '%' }" aria-hidden="true"></div>
                                <div class="absolute h-5 w-5 bg-white rounded-full -top-1 border-2 border-indigo-500 shadow-md group-hover:scale-110 transition-transform"
                                     :style="{ left: progressPercent + '%', transform: 'translateX(-50%) translateY(-2px)' }" aria-hidden="true"></div>
                            </div>
                            <div class="flex justify-between items-center text-sm text-stone-400 mb-4 tabular-nums">
                                <span>{{ formatTime(currentTime, true) }}</span>
                                <span>{{ formatTime(duration, true) }}</span>
                            </div>

                            <div class="grid grid-cols-2 gap-3 mb-2">
                                <button @click="setMarkIn" class="btn btn-secondary py-3 text-base">
                                    <i class="ph ph-arrow-square-down-left text-xl"></i>
                                    <span>Mark In</span>
                                    <span v-if="markInTime !== null" class="ml-auto text-xs tabular-nums">{{ formatTime(markInTime) }}</span>
                                </button>
                                <button @click="setMarkOut" class="btn btn-secondary py-3 text-base">
                                    <i class="ph ph-arrow-square-up-right text-xl"></i>
                                    <span>Mark Out</span>
                                    <span v-if="markOutTime !== null" class="ml-auto text-xs tabular-nums">{{ formatTime(markOutTime) }}</span>
                                </button>
                            </div>
                        </div>

                        <main class="flex-grow overflow-y-auto p-4 sm:p-6 md:grid md:grid-cols-2 md:gap-x-6 md:gap-y-8">
                            <!-- Logging Form -->
                            <div class="mb-8 md:mb-0">
                                <h2 class="text-xl font-semibold text-stone-100 mb-3">Add Log Entry</h2>
                                <form @submit.prevent="saveLog" class="space-y-4">
                                    <div>
                                        <label for="logNotes" class="block text-sm font-medium text-stone-300 mb-1">Notes</label>
                                        <textarea id="logNotes" v-model="logForm.notes" rows="4" class="input-field" placeholder="Enter notes for this segment..."></textarea>
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-stone-300 mb-1">Rating</label>
                                        <div class="flex items-center gap-1">
                                            <button v-for="star in 5" :key="star" @click="logForm.rating = star" type="button" :aria-label="star + ' star rating'"
                                               class="p-1 rounded-full focus-visible:ring-2 focus-visible:ring-indigo-500 focus-visible:ring-offset-1 focus-visible:ring-offset-stone-900">
                                               <i class="ph-star text-3xl cursor-pointer transition-colors"
                                               :class="star <= logForm.rating ? 'ph-fill text-yellow-400 hover:text-yellow-300' : 'ph text-stone-600 hover:text-stone-500'"></i>
                                            </button>
                                            <button v-if="logForm.rating > 0" @click="logForm.rating = 0" type="button" class="ml-2 text-xs text-stone-400 hover:text-stone-200 focus-visible:underline">Clear</button>
                                        </div>
                                    </div>
                                    <div>
                                        <label for="logKeywords" class="block text-sm font-medium text-stone-300 mb-1">Keywords</label>
                                        <div class="flex items-center gap-2">
                                            <input type="text" id="logKeywords" v-model="logForm.newKeyword" @keydown.enter.prevent="addKeyword" @keydown.,.prevent="addKeyword"
                                                   class="input-field flex-grow" placeholder="Add keyword, press Enter or comma">
                                            <button type="button" @click="addKeyword" class="btn btn-secondary text-sm shrink-0">Add</button>
                                        </div>
                                        <div v-if="logForm.keywords.length > 0" class="mt-2 flex flex-wrap gap-2" aria-label="Selected keywords">
                                            <span v-for="kw in logForm.keywords" :key="kw"
                                                  class="flex items-center bg-indigo-600 text-white text-sm px-2.5 py-1 rounded-full">
                                                {{ kw }}
                                                <button @click="removeKeyword(kw)" type="button" class="ml-1.5 text-indigo-200 hover:text-white" :aria-label="'Remove keyword ' + kw">
                                                    <i class="ph ph-x text-xs font-bold"></i>
                                                </button>
                                            </span>
                                        </div>
                                    </div>
                                    <div class="flex gap-3 pt-2">
                                         <button type="submit" class="btn btn-primary w-full py-3 text-base" :disabled="markInTime === null || markOutTime === null || markInTime >= markOutTime || (!logForm.notes.trim() && logForm.keywords.length === 0 && logForm.rating === 0)">
                                            <i class="ph ph-floppy-disk text-xl"></i>
                                            <span>Save Log</span>
                                        </button>
                                        <button type="button" @click="resetLogForm" class="btn btn-secondary shrink-0">Reset Form</button>
                                    </div>
                                </form>
                            </div>

                            <!-- Saved Logs List -->
                            <div class="mt-8 md:mt-0">
                                <h2 class="text-xl font-semibold text-stone-100 mb-3">Saved Logs ({{ logsForCurrentVideo.length }})</h2>
                                <div v-if="logsForCurrentVideo.length === 0" class="text-stone-400 text-center py-6">
                                    <i class="ph ph-list-checks text-4xl mb-2"></i>
                                    <p>No logs saved for this video yet.</p>
                                </div>
                                <ul v-else class="space-y-3 max-h-[calc(100vh-var(--logging-station-header-height,300px)-var(--logging-station-form-height,300px))] md:max-h-none overflow-y-auto">
                                    <li v-for="log in logsForCurrentVideo" :key="log.id" class="card p-3 sm:p-4">
                                        <div class="flex justify-between items-start mb-1">
                                            <div class="font-semibold text-stone-300 text-sm tabular-nums">
                                                {{ formatTime(log.markIn) }} - {{ formatTime(log.markOut) }}
                                            </div>
                                            <div class="flex items-center shrink-0">
                                                <span class="flex items-center mr-2" :aria-label="log.rating + ' out of 5 stars'">
                                                    <i v-for="s_idx in 5" :key="s_idx" class="ph-star text-sm mr-px" :class="s_idx <= log.rating ? 'ph-fill text-yellow-400' : 'ph text-stone-600'"></i>
                                                </span>
                                                <button @click="seekVideo(log.markIn)" class="btn btn-secondary btn-sm px-2 py-1 text-xs">
                                                    <i class="ph ph-play-circle text-base"></i><span>Go</span>
                                                </button>
                                            </div>
                                        </div>
                                        <p class="text-sm text-stone-400 whitespace-pre-wrap my-1 break-words">{{ log.notes || 'No notes.' }}</p>
                                        <div v-if="log.keywords && log.keywords.length > 0" class="mt-1">
                                            <span v-for="kw in log.keywords" :key="kw" class="inline-block bg-indigo-500/20 text-indigo-300 text-xs px-2 py-0.5 rounded-full mr-1 mb-1">{{ kw }}</span>
                                        </div>
                                    </li>
                                </ul>
                            </div>
                        </main>
                    </div>

                    <!-- Play Selects Modal -->
                    <Transition name="fade">
                    <div v-if="showPlaySelectsModal" ref="playSelectsModalElement" class="fixed inset-0 bg-black/90 flex flex-col items-center justify-center p-4 z-50" @click.self="closePlaySelectsModal" role="dialog" aria-modal="true" aria-labelledby="playSelectsModalTitle">
                        <div class="relative w-full max-w-4xl flex flex-col bg-stone-900 rounded-lg shadow-xl overflow-hidden max-h-[90vh]">
                            <header class="p-4 border-b border-stone-800 flex items-center justify-between shrink-0">
                                <h3 id="playSelectsModalTitle" class="text-lg font-semibold text-stone-100">Play Selects</h3>
                                <button @click="closePlaySelectsModal" class="btn btn-secondary btn-sm p-1" aria-label="Close player">
                                    <i class="ph ph-x text-xl"></i>
                                </button>
                            </header>
                            <div class="flex-grow flex items-center justify-center p-4">
                                <video ref="playSelectsPlayerRef" :src="playSelectsVideoSrc"
                                       @timeupdate="handlePlaySelectsTimeUpdate"
                                       @loadeddata="handlePlaySelectsLoadedData"
                                       @ended="handlePlaySelectsTimeUpdate" <!-- Call timeupdate on ended to potentially advance -->
                                       class="w-full max-h-[70vh] rounded-md bg-black aspect-video" controls></video>
                            </div>
                            <footer class="p-4 border-t border-stone-800 shrink-0 text-center">
                                <p v-if="playSelectsLogs.length > 0 && currentSelectIndex < playSelectsLogs.length" class="text-stone-200 text-sm mb-2">
                                    Playing Select {{ currentSelectIndex + 1 }} of {{ playSelectsLogs.length }}: {{ formatTime(playSelectsLogs[currentSelectIndex].markIn) }} - {{ formatTime(playSelectsLogs[currentSelectIndex].markOut) }}
                                </p>
                                <p v-else-if="playSelectsLogs.length > 0 && currentSelectIndex >= playSelectsLogs.length" class="text-stone-200 text-sm mb-2">
                                    Finished playing all selects.
                                </p>
                                <div v-if="playSelectsLogs.length > 0 && currentSelectIndex < playSelectsLogs.length" class="text-xs text-stone-400 truncate">
                                    {{ playSelectsLogs[currentSelectIndex].notes || 'No notes for this select.'}}
                                </div>
                            </footer>
                        </div>
                    </div>
                    </Transition>
                `
            };

            createApp(App).mount('#app');

        } catch (e) {
            console.error('TOP LEVEL CRITICAL ERROR (before Vue mount):', e);
            const appDiv = document.getElementById('app');
            if (appDiv && !document.querySelector('.critical-error-display')) { // Avoid multiple error messages
                 const errorDiv = document.createElement('div');
                 errorDiv.className = 'critical-error-display'; // Class for potential future styling/selection
                 errorDiv.style.cssText = 'color: red; background-color: black; padding: 20px; border: 2px solid red; position: fixed; top: 10px; left: 10px; right: 10px; z-index: 9999; font-size: 12px; white-space: pre-wrap; word-break: break-all;';
                errorDiv.innerHTML = `<h2>FATAL ERROR: Application could not start.</h2>
                    <p>This is usually due to a JavaScript error during initialization.</p>
                    <p>Please check the browser console (usually F12 or Right-click -> Inspect -> Console) for specific error messages.</p>
                    <p><strong>Error:</strong> ${e.message}</p>
                    <pre><strong>Stack:</strong><br>${e.stack}</pre>
                </div>`;
                 if (document.body) { // Ensure body exists
                    document.body.prepend(errorDiv); // Prepend to show on top
                } else { // Fallback if body isn't ready
                    appDiv.innerHTML = errorDiv.outerHTML;
                }
            }
        }
    </script>
</body>
</html>
