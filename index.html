<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>LogReel - Client-Side Video Logging</title>
    <style>
        /* CSS Reset (Minimal) */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: #e0e0e0;
            background-color: #1a1a1a; /* Dark background */
            overscroll-behavior-y: contain; /* Prevent pull-to-refresh on mobile */
        }

        body {
            display: flex;
            flex-direction: column;
        }

        #app {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }

        /* Theme Variables */
        :root {
            --primary-color: #007bff; /* A nice blue */
            --primary-hover: #0056b3;
            --secondary-color: #6c757d;
            --background-color: #1a1a1a;
            --surface-color: #2c2c2c; /* Cards, inputs */
            --text-color: #e0e0e0;
            --text-muted-color: #a0a0a0;
            --border-color: #444;
            --error-color: #dc3545;
            --success-color: #28a745;
            --star-color: #ffc107;
            --timeline-played-color: var(--primary-color);
            --timeline-buffered-color: #555;
            --timeline-mark-color: var(--star-color);
        }

        /* General Styles */
        h1, h2, h3 {
            margin-bottom: 0.75em;
            color: var(--text-color);
        }

        button, input[type="text"], textarea, select {
            font-family: inherit;
            font-size: 1rem;
            padding: 0.6em 1em;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--surface-color);
            color: var(--text-color);
        }

        button {
            cursor: pointer;
            background-color: var(--primary-color);
            color: white;
            border: none;
            transition: background-color 0.2s ease;
        }
        button:hover:not(:disabled) {
            background-color: var(--primary-hover);
        }
        button:disabled {
            background-color: var(--secondary-color);
            cursor: not-allowed;
            opacity: 0.7;
        }
        button.secondary {
            background-color: var(--secondary-color);
        }
        button.secondary:hover:not(:disabled) {
            background-color: #5a6268;
        }
        button.danger {
            background-color: var(--error-color);
        }
        button.danger:hover:not(:disabled) {
            background-color: #c82333;
        }
        .icon-button {
            background: none;
            border: none;
            color: var(--text-muted-color);
            padding: 0.5em;
            font-size: 1.2rem;
        }
        .icon-button:hover {
            color: var(--primary-color);
        }


        input[type="text"], textarea {
            width: 100%;
            margin-bottom: 0.5em;
        }
        textarea {
            min-height: 80px;
            resize: vertical;
        }

        .screen {
            padding: 1.5em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Allow content to scroll */
        }
        .screen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5em;
            padding-bottom: 0.5em;
            border-bottom: 1px solid var(--border-color);
        }
        .screen-header h1, .screen-header h2 {
            margin-bottom: 0;
            font-size: 1.5rem;
        }
        .back-button {
            font-size: 1rem;
            padding: 0.5em 0.8em;
        }

        .empty-state {
            text-align: center;
            color: var(--text-muted-color);
            padding: 2em;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            margin-top: 2em;
        }
        .empty-state p { margin-bottom: 1em; }

        /* Project Dashboard (Screen A) */
        #project-list {
            list-style: none;
            padding: 0;
        }
        .project-item {
            background-color: var(--surface-color);
            padding: 1em 1.5em;
            margin-bottom: 1em;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .project-item:hover {
            background-color: #3a3a3a;
        }
        .project-item-info h3 {
            margin-bottom: 0.25em;
            font-size: 1.2rem;
        }
        .project-item-info span {
            font-size: 0.9rem;
            color: var(--text-muted-color);
        }
        .project-item-actions button {
            margin-left: 0.5em;
            padding: 0.4em 0.6em; /* Smaller delete button */
            font-size: 0.9rem;
        }

        /* Assembly Hub (Screen B) */
        #assembly-hub-screen .search-bar {
            width: 100%;
            margin-bottom: 1.5em;
        }
        #video-list {
            display: grid;
            gap: 1.5em;
            grid-template-columns: 1fr; /* Mobile first */
        }
        @media (min-width: 768px) { /* Tablet and up */
            #video-list {
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            }
        }

        .video-card {
            background-color: var(--surface-color);
            border-radius: 8px;
            padding: 1em;
            display: flex;
            flex-direction: column;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .video-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* Align star to top */
            margin-bottom: 0.75em;
        }
        .video-card-header h4 {
            font-size: 1.1rem;
            word-break: break-all; /* Prevent long filenames from breaking layout */
            margin-right: 0.5em; /* Space for star */
            flex-grow: 1;
        }
        .video-card-header .video-number {
            color: var(--text-muted-color);
            font-weight: bold;
            margin-right: 0.5em;
        }
        .star-toggle {
            font-size: 1.5rem; /* Larger star */
            color: var(--text-muted-color);
            cursor: pointer;
        }
        .star-toggle.important {
            color: var(--star-color);
        }
        .video-thumbnail-placeholder {
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
            background-color: #444;
            border-radius: 4px;
            margin-bottom: 0.75em;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted-color);
        }
        .video-card-meta {
            font-size: 0.9rem;
            color: var(--text-muted-color);
            margin-bottom: 1em;
        }
        .video-card-actions {
            display: flex;
            gap: 0.5em; /* Space between buttons */
            margin-top: auto; /* Push actions to bottom */
        }
        .video-card-actions button {
            flex-grow: 1;
        }
        .video-card-logs-summary {
            font-size: 0.9rem;
            color: var(--text-muted-color);
            margin-top: 0.5em;
            max-height: 100px; /* Limit height */
            overflow-y: auto;
            border-top: 1px solid var(--border-color);
            padding-top: 0.5em;
        }
        .video-card-logs-summary p { margin-bottom: 0.3em; }

        /* Logging Station (Screen C) */
        #logging-station-screen {
            display: flex;
            flex-direction: column;
        }
        .video-player-area {
            background-color: #000;
            margin-bottom: 1em;
            position: sticky; /* Sticky player on scroll for larger screens */
            top: 0;
            z-index: 10;
        }
        #video-player {
            width: 100%;
            max-height: 60vh; /* Limit player height */
            display: block; /* Remove extra space below video */
        }
        .video-timeline-container {
            position: relative;
            height: 10px;
            background-color: #333;
            cursor: pointer;
            margin: 0.5em 0;
        }
        .timeline-progress, .timeline-mark-in-out {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
        }
        .timeline-progress {
            background-color: var(--timeline-played-color);
            z-index: 2;
        }
        .timeline-mark-in-out {
            background-color: var(--timeline-mark-color);
            opacity: 0.5;
            z-index: 1;
        }

        .logging-controls {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on small screens */
            gap: 1em;
            margin-bottom: 1.5em;
            align-items: center;
        }
        .logging-controls button { padding: 0.8em 1.2em; }
        .mark-time { font-size: 0.8em; color: var(--text-muted-color); display: block; }

        .log-form {
            background-color: var(--surface-color);
            padding: 1.5em;
            border-radius: 8px;
            margin-bottom: 1.5em;
        }
        .star-rating {
            display: flex;
            margin-bottom: 1em;
        }
        .star-rating .star {
            font-size: 1.8rem;
            color: var(--text-muted-color);
            cursor: pointer;
            margin-right: 0.25em;
        }
        .star-rating .star.selected, .star-rating .star:hover {
            color: var(--star-color);
        }
        .keywords-input-area { margin-bottom: 1em; }
        .keywords-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5em;
            margin-top: 0.5em;
            padding: 0.5em;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            min-height: 30px;
        }
        .keyword-tag {
            background-color: var(--primary-color);
            color: white;
            padding: 0.3em 0.6em;
            border-radius: 4px;
            font-size: 0.9em;
            display: flex;
            align-items: center;
        }
        .keyword-tag .remove-keyword {
            margin-left: 0.5em;
            cursor: pointer;
            font-weight: bold;
        }

        .saved-logs-list {
            flex-grow: 1; /* Take remaining space */
            overflow-y: auto; /* Scroll for logs */
        }
        .log-item {
            background-color: var(--surface-color);
            padding: 1em;
            margin-bottom: 1em;
            border-radius: 8px;
            border-left: 4px solid var(--primary-color);
        }
        .log-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5em;
        }
        .log-item-time { font-weight: bold; color: var(--text-color); }
        .log-item-rating { color: var(--star-color); }
        .log-item-notes { margin-bottom: 0.5em; white-space: pre-wrap; word-wrap: break-word; }
        .log-item-keywords .keyword-tag {
            background-color: var(--secondary-color); /* Different color for display */
            margin-right: 0.3em;
            margin-bottom: 0.3em;
            display: inline-flex; /* Fit tags in line */
        }
        .log-item-actions { margin-top: 0.75em; display: flex; gap: 0.5em; justify-content: flex-end; }


        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1em;
        }
        .modal-content {
            background-color: var(--surface-color);
            padding: 2em;
            border-radius: 8px;
            max-width: 90vw;
            width: 500px; /* Default width */
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1em;
        }
        .modal-header h3 { margin-bottom: 0; }
        .close-modal-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-muted-color);
            cursor: pointer;
        }
        .modal-actions { margin-top: 1.5em; display: flex; justify-content: flex-end; gap: 0.5em; }

        #preview-selects-player { width: 100%; margin-bottom: 1em; }
        #preview-selects-info { text-align: center; margin-bottom: 1em; color: var(--text-muted-color); }
        #preview-selects-notes-label {
            color: var(--text-color);
            font-weight: bold;
            display: block;
            margin-bottom: 0.3em;
        }
        #preview-selects-notes {
            background-color: #333;
            padding: 0.5em;
            border-radius: 4px;
            min-height: 50px;
            margin-bottom: 1em;
            font-size: 0.9em;
            white-space: pre-wrap;
            color: var(--text-color);
        }

        /* Notifications */
        #notifications-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .notification {
            padding: 1em 1.5em;
            border-radius: 6px;
            color: white;
            min-width: 250px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            opacity: 0;
            transform: translateX(100%);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        .notification.info { background-color: var(--primary-color); }
        .notification.success { background-color: var(--success-color); }
        .notification.error { background-color: var(--error-color); }

        /* Utility classes */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .mt-1 { margin-top: 1em; }
        .mb-1 { margin-bottom: 1em; }
        .button-group { display: flex; gap: 0.5em; }

    </style>
</head>
<body>
    <div id="app">
        <!-- Screen A: Project Dashboard -->
        <section id="project-dashboard-screen" class="screen hidden">
            <div class="screen-header">
                <h1>LogReel</h1>
                <button id="export-all-data-btn" class="secondary">Export All Data</button>
            </div>
            <button id="create-new-project-btn" class="mb-1">Create New Project</button>
            <ul id="project-list">
                <!-- Project items will be dynamically inserted here -->
            </ul>
            <div id="project-dashboard-empty-state" class="empty-state hidden">
                <p>No projects yet.</p>
                <p>Click "Create New Project" to get started!</p>
            </div>
        </section>

        <!-- Screen B: Assembly Hub (Project View) -->
        <section id="assembly-hub-screen" class="screen hidden">
            <div class="screen-header">
                <button id="assembly-back-to-dashboard-btn" class="back-button">< Projects</button>
                <h2 id="assembly-project-title">Project Name</h2>
            </div>
            <input type="text" id="assembly-search-bar" class="search-bar" placeholder="Search videos or logs (filename, notes, keywords)...">
            <div class="button-group mb-1">
                <button id="add-videos-btn">Add Video(s)</button>
                <input type="file" id="video-file-input" multiple accept="video/*" class="hidden">
            </div>
            <div id="video-list">
                <!-- Video cards will be dynamically inserted here -->
            </div>
            <div id="assembly-hub-empty-state" class="empty-state hidden">
                <p>No videos in this project yet.</p>
                <p>Click "Add Video(s)" to import your footage.</p>
            </div>
        </section>

        <!-- Screen C: Logging Station (Individual Video View) -->
        <section id="logging-station-screen" class="screen hidden">
            <div class="screen-header">
                <button id="logging-back-to-assembly-btn" class="back-button">< Project Videos</button>
                <h2 id="logging-video-filename">Video Filename.mp4</h2>
            </div>

            <div class="video-player-area">
                <video id="video-player" controls></video>
                <div class="video-timeline-container" id="video-timeline-container">
                    <div class="timeline-mark-in-out" id="timeline-mark-in-out"></div>
                    <div class="timeline-progress" id="timeline-progress"></div>
                </div>
                <div class="button-group" style="justify-content: space-around; padding: 0.5em 0;">
                    <label for="playback-speed">Speed:</label>
                    <select id="playback-speed">
                        <option value="0.25">0.25x</option>
                        <option value="0.5">0.5x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1" selected>1x</option>
                        <option value="1.25">1.25x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                    </select>
                </div>
            </div>

            <div class="logging-controls">
                <button id="mark-in-btn">Mark In <span class="mark-time" id="mark-in-time-display">00:00:00.000</span></button>
                <button id="mark-out-btn">Mark Out <span class="mark-time" id="mark-out-time-display">00:00:00.000</span></button>
            </div>

            <div class="log-form">
                <h3>Create New Log</h3>
                <label for="log-notes">Notes:</label>
                <textarea id="log-notes" placeholder="Enter notes for this segment..."></textarea>
                
                <label>Rating:</label>
                <div class="star-rating" id="log-rating">
                    <span class="star" data-value="1">☆</span>
                    <span class="star" data-value="2">☆</span>
                    <span class="star" data-value="3">☆</span>
                    <span class="star" data-value="4">☆</span>
                    <span class="star" data-value="5">☆</span>
                </div>
                
                <label for="log-keywords-input">Keywords (press Enter to add):</label>
                <div class="keywords-input-area">
                    <input type="text" id="log-keywords-input" placeholder="e.g., b-roll, interview, good take">
                    <div class="keywords-container" id="log-keywords-container">
                        <!-- Keyword tags will appear here -->
                    </div>
                </div>
                <button id="save-log-btn">Save Log</button>
            </div>

            <h3>Saved Logs</h3>
            <div id="saved-logs-list" class="saved-logs-list">
                <!-- Log items will be dynamically inserted here -->
            </div>
            <div id="logging-station-empty-state" class="empty-state hidden">
                <p>No logs created for this video yet.</p>
                <p>Use the controls above to mark segments and save your logs.</p>
            </div>
        </section>

        <!-- Modals -->
        <div id="preview-selects-modal" class="modal hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Preview Selects</h3>
                    <button class="close-modal-btn" data-target-modal="preview-selects-modal">×</button>
                </div>
                <video id="preview-selects-player" controls></video>
                <div id="preview-selects-info">Playing Select X of Y</div>
                <div id="preview-selects-notes-label">Current Select Notes:</div>
                <div id="preview-selects-notes"></div>
                <div class="modal-actions">
                    <button class="secondary close-modal-btn" data-target-modal="preview-selects-modal">Close</button>
                </div>
            </div>
        </div>

        <div id="confirm-dialog" class="modal hidden">
            <div class="modal-content">
                <h3 id="confirm-dialog-title">Confirm Action</h3>
                <p id="confirm-dialog-message">Are you sure?</p>
                <div class="modal-actions">
                    <button id="confirm-dialog-cancel-btn" class="secondary">Cancel</button>
                    <button id="confirm-dialog-confirm-btn" class="danger">Confirm</button>
                </div>
            </div>
        </div>

        <div id="notifications-container"></div>
    </div>

<script>
(function() {
    'use strict';

    // --- App State ---
    const state = {
        currentScreen: null, // Will be set by navigateTo
        currentProjectId: null,
        currentProjectName: '',
        currentVideoId: null,
        currentVideoFile: null,
        currentVideoFilename: '',
        currentVideoDuration: 0,
        currentMarkIn: null,
        currentMarkOut: null,
        currentLogRating: 0,
        // currentLogKeywords: [], // This will be managed locally in the log form section
    };

    // --- DOM Elements Cache ---
    const DOMElements = {};

    // --- Database (IndexedDB) ---
    const DB_NAME = 'LogReelDB';
    const DB_VERSION = 1; // Increment if schema changes
    const STORE_PROJECTS = 'projects';
    const STORE_VIDEOS = 'videos'; // Stores video metadata AND File objects
    const STORE_LOGS = 'logs';
    let db;

    async function initDB() {
        console.log("[DB] Initializing Database...");
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onerror = (event) => {
                console.error("[DB] Database error:", event.target.error);
                reject("Database error: " + event.target.error);
            };

            request.onupgradeneeded = (event) => {
                console.log("[DB] Upgrade needed or DB creation.");
                db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_PROJECTS)) {
                    console.log("[DB] Creating object store:", STORE_PROJECTS);
                    db.createObjectStore(STORE_PROJECTS, { keyPath: 'id', autoIncrement: true });
                }
                if (!db.objectStoreNames.contains(STORE_VIDEOS)) {
                    console.log("[DB] Creating object store:", STORE_VIDEOS);
                    const videoStore = db.createObjectStore(STORE_VIDEOS, { keyPath: 'id', autoIncrement: true });
                    videoStore.createIndex('projectId', 'projectId', { unique: false });
                     // It's good practice to also index filename if you search by it often, though full text search is complex in IDB
                    videoStore.createIndex('filename', 'filename', { unique: false });
                }
                if (!db.objectStoreNames.contains(STORE_LOGS)) {
                    console.log("[DB] Creating object store:", STORE_LOGS);
                    const logStore = db.createObjectStore(STORE_LOGS, { keyPath: 'id', autoIncrement: true });
                    logStore.createIndex('videoId', 'videoId', { unique: false });
                    logStore.createIndex('projectId', 'projectId', { unique: false }); // For easier cleanup/export
                }
                 console.log("[DB] Upgrade complete.");
            };

            request.onsuccess = (event) => {
                db = event.target.result;
                console.log("[DB] Database initialized successfully.");
                db.onerror = (event) => { // Generic error handler for the DB connection
                    console.error("[DB] Generic Database Error:", event.target.error);
                    showNotification("A database error occurred. Some operations might fail.", "error");
                };
                resolve(db);
            };
        });
    }

    // --- DB Helper Functions with more logging ---
    async function dbOperation(storeName, mode, operation, ...args) {
        return new Promise((resolve, reject) => {
            if (!db) {
                console.error(`[DB OP] DB not initialized for ${storeName} ${operation.name}`);
                return reject("DB not initialized");
            }
            try {
                const transaction = db.transaction([storeName], mode);
                const store = transaction.objectStore(storeName);
                const request = operation(store, ...args);

                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => {
                    console.error(`[DB OP ERROR] ${storeName} ${mode} ${operation.name}:`, event.target.error, "Args:", args);
                    reject(`Error in ${operation.name}: ${event.target.error}`);
                };
            } catch (error) {
                 console.error(`[DB OP EXCEPTION] ${storeName} ${mode} ${operation.name}:`, error, "Args:", args);
                 reject(`Exception in ${operation.name}: ${error.message}`);
            }
        });
    }

    async function dbAdd(storeName, item) {
        return dbOperation(storeName, 'readwrite', (store, item) => store.add(item), item);
    }
    async function dbGetAll(storeName) {
        return dbOperation(storeName, 'readonly', (store) => store.getAll());
    }
    async function dbGetById(storeName, id) {
        return dbOperation(storeName, 'readonly', (store, id) => store.get(id), id);
    }
    async function dbGetByIndex(storeName, indexName, query) {
        return dbOperation(storeName, 'readonly', (store, indexName, query) => store.index(indexName).getAll(query), indexName, query);
    }
    async function dbUpdate(storeName, item) {
        return dbOperation(storeName, 'readwrite', (store, item) => store.put(item), item);
    }
    async function dbDelete(storeName, key) {
        return dbOperation(storeName, 'readwrite', (store, key) => store.delete(key), key);
    }


    // --- Router ---
    function navigateTo(screenId, params = {}) {
        console.log(`[NAVIGATE] Attempting to navigate to: ${screenId} with params:`, params);

        document.querySelectorAll('.screen').forEach(s => {
            // console.log(`[NAVIGATE] Hiding screen: ${s.id}`);
            if (s) s.classList.add('hidden');
        });

        const targetScreenElement = DOMElements[screenId + 'Screen'];

        if (targetScreenElement) {
            console.log(`[NAVIGATE] Showing screen: ${targetScreenElement.id}`);
            targetScreenElement.classList.remove('hidden');
        } else {
            console.error(`[NAVIGATE] Target screen element NOT FOUND in DOMElements for screenId: "${screenId}". DOMElements object:`, DOMElements);
            showNotification(`Error: Could not find screen UI for "${screenId}".`, "error");
            // Fallback to dashboard if intended screen isn't found, to prevent blank page.
            if (screenId !== 'project-dashboard' && DOMElements.projectDashboardScreen) {
                console.warn(`[NAVIGATE] Fallback: Navigating to project-dashboard as ${screenId} was not found.`);
                DOMElements.projectDashboardScreen.classList.remove('hidden');
                state.currentScreen = 'project-dashboard';
                loadAndRenderProjects(); // Load its content
            }
            return;
        }

        state.currentScreen = screenId;
        window.scrollTo(0, 0);
        console.log(`[NAVIGATE] Current screen state set to: ${state.currentScreen}`);

        // Handle specific screen initializations
        if (screenId === 'project-dashboard') {
            console.log("[NAVIGATE] Loading projects for dashboard...");
            loadAndRenderProjects();
        } else if (screenId === 'assembly-hub') {
            state.currentProjectId = params.projectId;
            // Ensure project name is also fetched/passed if needed for title, or fetch it here.
            // For now, assume params.projectName is provided.
            state.currentProjectName = params.projectName || "Project"; // Fallback name
            if (DOMElements.assemblyProjectTitle) {
                DOMElements.assemblyProjectTitle.textContent = sanitizeHTML(state.currentProjectName);
            } else {
                 console.warn("[NAVIGATE] assemblyProjectTitle DOM element not found for Assembly Hub.");
            }
            console.log(`[NAVIGATE] Loading videos for project: ${state.currentProjectName} (ID: ${state.currentProjectId})`);
            loadAndRenderVideosForProject(state.currentProjectId);
            if (DOMElements.assemblySearchBar) DOMElements.assemblySearchBar.value = ''; // Clear search bar
        } else if (screenId === 'logging-station') {
            state.currentProjectId = params.projectId; // Keep track of project context
            state.currentProjectName = params.projectName;
            state.currentVideoId = params.videoId;
            state.currentVideoFilename = params.videoFilename;
            state.currentVideoFile = params.videoFile;
            if (DOMElements.loggingVideoFilename) {
                 DOMElements.loggingVideoFilename.textContent = sanitizeHTML(state.currentVideoFilename);
            } else {
                console.warn("[NAVIGATE] loggingVideoFilename DOM element not found for Logging Station.");
            }
            console.log(`[NAVIGATE] Setting up logging station for video: ${state.currentVideoFilename}`);
            setupLoggingStation();
        }
        console.log(`[NAVIGATE] Navigation to ${screenId} complete.`);
    }

    // --- Utility Functions ---
    function formatTime(totalSeconds, showMilliseconds = false) {
        if (isNaN(totalSeconds) || totalSeconds < 0) totalSeconds = 0;
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = Math.floor(totalSeconds % 60);
        const milliseconds = Math.floor((totalSeconds - Math.floor(totalSeconds)) * 1000);

        let timeStr = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        if (showMilliseconds) {
            timeStr += `.${String(milliseconds).padStart(3, '0')}`;
        }
        return timeStr;
    }

    function showNotification(message, type = 'info', duration = 3000) {
        if (!DOMElements.notificationsContainer) {
            console.warn("Notifications container not found. Message:", message);
            return;
        }
        const container = DOMElements.notificationsContainer;
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;
        
        container.appendChild(notification);
        void notification.offsetWidth; 
        notification.classList.add('show');

        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => {
                if (container.contains(notification)) {
                     container.removeChild(notification);
                }
            }, 300);
        }, duration);
    }

    function showConfirmDialog(title, message, onConfirmCallback) { // Modified to use callback directly
        if (!DOMElements.confirmDialog || !DOMElements.confirmDialogTitle || !DOMElements.confirmDialogMessage || !DOMElements.confirmDialogConfirmBtn || !DOMElements.confirmDialogCancelBtn) {
            console.error("Confirm dialog elements not found.");
            // Fallback to browser confirm if UI is broken
            if (window.confirm(`${title}\n${message}`)) {
                if (onConfirmCallback) onConfirmCallback(true);
            } else {
                if (onConfirmCallback) onConfirmCallback(false);
            }
            return;
        }
        DOMElements.confirmDialogTitle.textContent = title;
        DOMElements.confirmDialogMessage.textContent = message;
        DOMElements.confirmDialog.classList.remove('hidden');

        // Remove previous listeners to avoid multiple fires
        const newConfirmBtn = DOMElements.confirmDialogConfirmBtn.cloneNode(true);
        DOMElements.confirmDialogConfirmBtn.parentNode.replaceChild(newConfirmBtn, DOMElements.confirmDialogConfirmBtn);
        DOMElements.confirmDialogConfirmBtn = newConfirmBtn;
        
        const newCancelBtn = DOMElements.confirmDialogCancelBtn.cloneNode(true);
        DOMElements.confirmDialogCancelBtn.parentNode.replaceChild(newCancelBtn, DOMElements.confirmDialogCancelBtn);
        DOMElements.confirmDialogCancelBtn = newCancelBtn;


        DOMElements.confirmDialogConfirmBtn.onclick = () => {
            DOMElements.confirmDialog.classList.add('hidden');
            if (onConfirmCallback) onConfirmCallback(true);
        };
        DOMElements.confirmDialogCancelBtn.onclick = () => {
            DOMElements.confirmDialog.classList.add('hidden');
            if (onConfirmCallback) onConfirmCallback(false);
        };
    }
    
    function sanitizeHTML(str) {
        if (typeof str !== 'string') return '';
        const temp = document.createElement('div');
        temp.textContent = str;
        return temp.innerHTML;
    }


    // --- Project Dashboard (Screen A) ---
    async function loadAndRenderProjects() {
        console.log("[PROJECTS] Loading and rendering projects...");
        if (!DOMElements.projectList || !DOMElements.projectDashboardEmptyState) {
            console.error("[PROJECTS] Project list or empty state DOM elements not found.");
            return;
        }
        try {
            const projects = await dbGetAll(STORE_PROJECTS);
            DOMElements.projectList.innerHTML = ''; 
            if (projects.length === 0) {
                DOMElements.projectDashboardEmptyState.classList.remove('hidden');
            } else {
                DOMElements.projectDashboardEmptyState.classList.add('hidden');
                // Use Promise.all to handle async video counts correctly
                const projectItemsPromises = projects.map(async (project) => {
                    let videoCount = 0;
                    try {
                        const videosInProject = await dbGetByIndex(STORE_VIDEOS, 'projectId', project.id);
                        videoCount = videosInProject.length;
                    } catch (countError) {
                        console.error(`[PROJECTS] Error counting videos for project ${project.id}:`, countError);
                    }

                    const li = document.createElement('li');
                    li.className = 'project-item';
                    li.dataset.projectId = project.id;
                    li.dataset.projectName = project.name; // Store name for navigation
                    li.innerHTML = `
                        <div class="project-item-info">
                            <h3>${sanitizeHTML(project.name)}</h3>
                            <span>${videoCount} video(s)</span>
                        </div>
                        <div class="project-item-actions">
                            <button class="danger delete-project-btn" data-project-id="${project.id}">Delete</button>
                        </div>
                    `;
                    // Add event listener to the info part for navigation
                    const infoDiv = li.querySelector('.project-item-info');
                    if (infoDiv) {
                        infoDiv.addEventListener('click', () => {
                            navigateTo('assembly-hub', { projectId: project.id, projectName: project.name });
                        });
                    }
                    return li;
                });
                const projectListItems = await Promise.all(projectItemsPromises);
                projectListItems.forEach(item => DOMElements.projectList.appendChild(item));
            }
            console.log("[PROJECTS] Projects rendered.");
        } catch (error) {
            console.error("[PROJECTS] Error loading projects:", error);
            showNotification("Failed to load projects.", "error");
            DOMElements.projectDashboardEmptyState.classList.remove('hidden'); // Show empty state on error
            DOMElements.projectList.innerHTML = '<li>Error loading projects.</li>';
        }
    }

    async function handleCreateNewProject() {
        const projectName = prompt("Enter project name:");
        if (projectName && projectName.trim() !== "") {
            try {
                const newProject = { name: projectName.trim(), createdAt: new Date().toISOString() };
                await dbAdd(STORE_PROJECTS, newProject);
                showNotification(`Project "${sanitizeHTML(newProject.name)}" created.`, "success");
                loadAndRenderProjects();
            } catch (error) {
                console.error("Error creating project:", error);
                showNotification("Failed to create project.", "error");
            }
        }
    }

    async function handleDeleteProject(projectId) {
        const project = await dbGetById(STORE_PROJECTS, projectId);
        if (!project) {
            showNotification("Project not found for deletion.", "error");
            return;
        }
        
        showConfirmDialog(
            "Delete Project",
            `Are you sure you want to delete project "${sanitizeHTML(project.name)}" and all its ${project.videoCount || ''} videos and logs? This action cannot be undone.`,
            async (confirmed) => {
                if (confirmed) {
                    try {
                        console.log(`[PROJECTS] Deleting project ID: ${projectId}`);
                        // Delete logs associated with this project
                        const logs = await dbGetByIndex(STORE_LOGS, 'projectId', projectId);
                        for (const log of logs) {
                            await dbDelete(STORE_LOGS, log.id);
                        }
                        console.log(`[PROJECTS] Deleted ${logs.length} logs for project ${projectId}.`);

                        // Delete videos associated with this project
                        const videos = await dbGetByIndex(STORE_VIDEOS, 'projectId', projectId);
                        for (const video of videos) {
                            await dbDelete(STORE_VIDEOS, video.id);
                        }
                        console.log(`[PROJECTS] Deleted ${videos.length} videos for project ${projectId}.`);

                        // Delete the project itself
                        await dbDelete(STORE_PROJECTS, projectId);
                        showNotification(`Project "${sanitizeHTML(project.name)}" deleted.`, "success");
                        loadAndRenderProjects(); // Refresh the list
                    } catch (error) {
                        console.error("Error deleting project assets:", error);
                        showNotification("Failed to delete project and its assets.", "error");
                    }
                }
            }
        );
    }

    // --- Assembly Hub (Screen B) ---
    async function loadAndRenderVideosForProject(projectId, searchTerm = '') {
        console.log(`[ASSEMBLY] Loading videos for project ID: ${projectId}, search: "${searchTerm}"`);
        if (!DOMElements.videoList || !DOMElements.assemblyHubEmptyState) {
             console.error("[ASSEMBLY] Video list or empty state DOM elements not found.");
             return;
        }
        try {
            let videos = await dbGetByIndex(STORE_VIDEOS, 'projectId', projectId);
            DOMElements.videoList.innerHTML = '';

            if (searchTerm) {
                searchTerm = searchTerm.toLowerCase().trim();
                const videoIdsWithMatchingLogs = new Set();
                if (searchTerm) { // Only search logs if there's a search term
                    const allLogsForProject = await dbGetByIndex(STORE_LOGS, 'projectId', projectId);
                    for (const log of allLogsForProject) {
                        if ( (log.notes && log.notes.toLowerCase().includes(searchTerm)) ||
                             (log.keywords && log.keywords.some(k => k.toLowerCase().includes(searchTerm))) ) {
                            videoIdsWithMatchingLogs.add(log.videoId);
                        }
                    }
                }
                videos = videos.filter(video => 
                    video.filename.toLowerCase().includes(searchTerm) || videoIdsWithMatchingLogs.has(video.id)
                );
            }
            
            videos.sort((a,b) => new Date(a.createdAt) - new Date(b.createdAt)); // Sort by creation time

            DOMElements.assemblyHubEmptyState.classList.toggle('hidden', videos.length > 0 || searchTerm);
            if (videos.length === 0 && searchTerm) {
                 DOMElements.videoList.innerHTML = `<p class="text-muted-color text-center" style="grid-column: 1 / -1;">No videos match your search: "${sanitizeHTML(searchTerm)}".</p>`;
            } else if (videos.length === 0 && !searchTerm) {
                DOMElements.assemblyHubEmptyState.classList.remove('hidden');
            }


            const videoCardPromises = videos.map(async (video, index) => {
                try {
                    const logs = await dbGetByIndex(STORE_LOGS, 'videoId', video.id);
                    const logCount = logs.length;

                    const card = document.createElement('div');
                    card.className = 'video-card';
                    card.dataset.videoId = video.id;
                    card.innerHTML = `
                        <div class="video-card-header">
                            <span class="video-number">${index + 1}.</span>
                            <h4>${sanitizeHTML(video.filename)}</h4>
                            <span class="star-toggle ${video.isImportant ? 'important' : ''}" data-video-id="${video.id}">★</span>
                        </div>
                        <div class="video-thumbnail-placeholder">
                            <span>Video Preview</span>
                        </div>
                        <div class="video-card-meta">
                            <span>${logCount} log(s)</span>
                        </div>
                        <div class="video-card-actions">
                            <button class="log-video-btn">Log Video</button>
                            <button class="preview-selects-btn" ${logCount === 0 ? 'disabled' : ''}>Preview Selects</button>
                        </div>
                        <button class="secondary view-video-logs-btn mt-1">View Logs (${logCount})</button>
                        <div class="video-card-logs-summary hidden"></div>
                        <button class="danger delete-video-btn mt-1">Delete Video</button>
                    `;
                    
                    card.querySelector('.log-video-btn').addEventListener('click', async () => {
                        // Re-fetch video to ensure fileObject is current, as it might not be passed if list is re-rendered
                        const currentVideoData = await dbGetById(STORE_VIDEOS, video.id);
                        if (!currentVideoData || !currentVideoData.fileObject) {
                            showNotification("Video file data not found. Please try re-adding the video.", "error");
                            console.error("Missing fileObject for video ID:", video.id, "Data:", currentVideoData);
                            return;
                        }
                        navigateTo('logging-station', { 
                            projectId: projectId, // Pass current project context
                            projectName: state.currentProjectName,
                            videoId: video.id, 
                            videoFilename: video.filename,
                            videoFile: currentVideoData.fileObject 
                        });
                    });
                    
                    card.querySelector('.star-toggle').addEventListener('click', () => toggleVideoImportant(video.id, projectId));
                    card.querySelector('.preview-selects-btn').addEventListener('click', () => handlePreviewSelects(video.id));
                    card.querySelector('.view-video-logs-btn').addEventListener('click', (e) => toggleLogsSummary(video.id, e.target));
                    card.querySelector('.delete-video-btn').addEventListener('click', () => handleDeleteVideo(video.id, projectId));
                    return card;
                } catch (cardError) {
                    console.error(`[ASSEMBLY] Error creating card for video ${video.filename}:`, cardError);
                    const errorCard = document.createElement('div');
                    errorCard.className = 'video-card';
                    errorCard.innerHTML = `<h4>Error loading ${sanitizeHTML(video.filename)}</h4><p>${sanitizeHTML(cardError.message)}</p>`;
                    return errorCard; // Return an error placeholder
                }
            });
            
            const videoCardElements = await Promise.all(videoCardPromises);
            videoCardElements.forEach(card => DOMElements.videoList.appendChild(card));
            console.log("[ASSEMBLY] Videos rendered.");

        } catch (error) {
            console.error("[ASSEMBLY] Error loading videos for project:", error);
            showNotification("Failed to load videos for this project.", "error");
            DOMElements.videoList.innerHTML = `<p class="text-muted-color text-center" style="grid-column: 1 / -1;">Error loading videos.</p>`;
            DOMElements.assemblyHubEmptyState.classList.add('hidden'); // Hide empty state on error, show error message instead
        }
    }
    
    async function toggleLogsSummary(videoId, button) {
        const card = button.closest('.video-card');
        if (!card) return;
        const summaryDiv = card.querySelector('.video-card-logs-summary');
        if (!summaryDiv) return;

        const isHidden = summaryDiv.classList.contains('hidden');

        if (isHidden) {
            try {
                const logs = await dbGetByIndex(STORE_LOGS, 'videoId', videoId);
                logs.sort((a,b) => a.inTime - b.inTime);
                summaryDiv.innerHTML = logs.length > 0 ? '' : '<p>No logs for this video.</p>';
                logs.forEach(log => {
                    const logEntry = document.createElement('p');
                    logEntry.textContent = `[${formatTime(log.inTime)} - ${formatTime(log.outTime)}] ${sanitizeHTML(log.notes.substring(0,50))}${log.notes.length > 50 ? '...' : ''}`;
                    summaryDiv.appendChild(logEntry);
                });
                summaryDiv.classList.remove('hidden');
                button.textContent = `Hide Logs`;
            } catch (error) {
                console.error("Error fetching logs for summary:", error);
                summaryDiv.innerHTML = '<p>Error loading logs.</p>';
                summaryDiv.classList.remove('hidden');
            }
        } else {
            summaryDiv.classList.add('hidden');
            const logCountMeta = card.querySelector('.video-card-meta span');
            const currentLogCount = logCountMeta ? parseInt(logCountMeta.textContent.split(' ')[0]) : 0;
            button.textContent = `View Logs (${currentLogCount})`;
        }
    }

    function handleAddVideos() {
        if (DOMElements.videoFileInput) DOMElements.videoFileInput.click();
    }

    async function processSelectedVideoFiles(files) {
        if (!state.currentProjectId) {
            showNotification("No project selected to add videos to.", "error");
            return;
        }
        if (!files || files.length === 0) return;

        console.log(`[ASSEMBLY] Processing ${files.length} selected files.`);
        let filesAddedCount = 0;
        let errorsCount = 0;

        // Process files one by one to avoid overwhelming IndexedDB or UI updates
        for (const file of files) {
            if (file.type.startsWith('video/')) {
                try {
                    const videoData = {
                        projectId: state.currentProjectId,
                        filename: file.name,
                        fileObject: file, // Store the actual File object
                        isImportant: false,
                        createdAt: new Date().toISOString()
                    };
                    await dbAdd(STORE_VIDEOS, videoData);
                    filesAddedCount++;
                } catch (error) {
                    errorsCount++;
                    console.error("Error adding video:", file.name, error);
                    showNotification(`Failed to add video: ${sanitizeHTML(file.name)}. ${error.message}`, "error", 5000);
                }
            } else {
                errorsCount++;
                showNotification(`File ${sanitizeHTML(file.name)} is not a valid video format.`, "error");
            }
        }

        if (filesAddedCount > 0) {
            showNotification(`${filesAddedCount} video(s) added successfully.`, "success");
        }
        if (errorsCount > 0 && filesAddedCount === 0) {
             showNotification(`No videos were added. ${errorsCount} file(s) had issues.`, "error");
        } else if (errorsCount > 0) {
            showNotification(`${errorsCount} file(s) could not be added.`, "error");
        }
        
        if (filesAddedCount > 0) {
            loadAndRenderVideosForProject(state.currentProjectId); // Refresh the list
        }
    }

    async function toggleVideoImportant(videoId, currentProjectId) { // Added currentProjectId for reload
        try {
            const video = await dbGetById(STORE_VIDEOS, videoId);
            if (video) {
                video.isImportant = !video.isImportant;
                await dbUpdate(STORE_VIDEOS, video);
                // No need to reload the whole list, just update the star UI directly if possible
                // but for simplicity and robustness, a quick reload is fine.
                loadAndRenderVideosForProject(currentProjectId, DOMElements.assemblySearchBar.value);
                showNotification(`Video marked as ${video.isImportant ? 'important' : 'not important'}.`, "info", 1500);
            }
        } catch (error) {
            console.error("Error toggling video importance:", error);
            showNotification("Failed to update video importance.", "error");
        }
    }

    async function handleDeleteVideo(videoId, projectId) {
        const video = await dbGetById(STORE_VIDEOS, videoId);
        if (!video) {
            showNotification("Video not found for deletion.", "error");
            return;
        }

        showConfirmDialog(
            "Delete Video",
            `Are you sure you want to delete video "${sanitizeHTML(video.filename)}" and all its logs? This action cannot be undone.`,
            async (confirmed) => {
                if (confirmed) {
                    try {
                        // Delete logs for this video
                        const logs = await dbGetByIndex(STORE_LOGS, 'videoId', videoId);
                        for (const log of logs) {
                            await dbDelete(STORE_LOGS, log.id);
                        }
                        // Delete video
                        await dbDelete(STORE_VIDEOS, videoId);
                        showNotification(`Video "${sanitizeHTML(video.filename)}" deleted.`, "success");
                        loadAndRenderVideosForProject(projectId, DOMElements.assemblySearchBar.value); // Reload videos
                    } catch (error) {
                        console.error("Error deleting video and its logs:", error);
                        showNotification("Failed to delete video.", "error");
                    }
                }
            }
        );
    }
    
    function handleAssemblySearch(event) {
        const searchTerm = event.target.value;
        loadAndRenderVideosForProject(state.currentProjectId, searchTerm);
    }


    // --- Logging Station (Screen C) ---
    let logVideoPlayer; 
    let currentLogKeywordsForm = []; // For the form inputs

    async function setupLoggingStation() {
        console.log("[LOGGING] Setting up logging station.");
        logVideoPlayer = DOMElements.videoPlayer;
        if (!logVideoPlayer) {
            console.error("[LOGGING] Video player element not found!");
            showNotification("Error: Video player UI missing.", "error");
            // Attempt to navigate back if critical UI is missing
            navigateTo('assembly-hub', { projectId: state.currentProjectId, projectName: state.currentProjectName });
            return;
        }

        resetLogForm(); // Clears form fields, ratings, keywords, mark in/out state
        loadLogsForCurrentVideo();

        // Ensure state.currentVideoFile is a File object
        if (state.currentVideoFile && state.currentVideoFile instanceof File) {
            try {
                if (logVideoPlayer.src && logVideoPlayer.src.startsWith('blob:')) {
                    URL.revokeObjectURL(logVideoPlayer.src);
                }
                logVideoPlayer.src = URL.createObjectURL(state.currentVideoFile);
                
                logVideoPlayer.onloadedmetadata = () => {
                    state.currentVideoDuration = logVideoPlayer.duration;
                    console.log("[LOGGING] Video metadata loaded. Duration:", state.currentVideoDuration);
                    updateMarkInOutDisplays(); // Update with 00:00:00 initially
                };
                logVideoPlayer.ontimeupdate = handleVideoTimeUpdate;
                logVideoPlayer.onseeked = handleVideoTimeUpdate; // Update displays after seeking
                
                if (DOMElements.timelineMarkInOut) {
                    DOMElements.timelineMarkInOut.style.width = '0%';
                    DOMElements.timelineMarkInOut.style.left = '0%';
                }
                if (DOMElements.playbackSpeed) DOMElements.playbackSpeed.value = logVideoPlayer.playbackRate = 1; // Reset speed

            } catch (error) {
                console.error("[LOGGING] Error setting up video player src:", error);
                showNotification("Could not load video. File might be corrupted or unsupported.", "error");
                navigateTo('assembly-hub', { projectId: state.currentProjectId, projectName: state.currentProjectName });
            }
        } else {
            console.error("[LOGGING] state.currentVideoFile is not a valid File object:", state.currentVideoFile);
            showNotification("Video file data is missing or invalid. Please re-select the video.", "error", 5000);
            
            // Attempt to fetch from DB as a last resort if it wasn't passed, though it should be.
            if (state.currentVideoId) {
                const videoData = await dbGetById(STORE_VIDEOS, state.currentVideoId);
                if (videoData && videoData.fileObject) {
                    console.log("[LOGGING] Found video file in DB, retrying setup.");
                    state.currentVideoFile = videoData.fileObject;
                    setupLoggingStation(); // Retry setup
                    return;
                }
            }
            navigateTo('assembly-hub', { projectId: state.currentProjectId, projectName: state.currentProjectName });
        }
    }

    function handleVideoTimeUpdate() {
        if (!logVideoPlayer || isNaN(logVideoPlayer.currentTime) || isNaN(state.currentVideoDuration) || state.currentVideoDuration === 0) return;
        
        const currentTime = logVideoPlayer.currentTime;
        if (DOMElements.timelineProgress) {
            const progressPercent = (currentTime / state.currentVideoDuration) * 100;
            DOMElements.timelineProgress.style.width = `${progressPercent}%`;
        }
        updateMarkInOutDisplays(currentTime);
    }
    
    function updateMarkInOutDisplays(currentTime) {
        if (currentTime === undefined && logVideoPlayer) currentTime = logVideoPlayer.currentTime;
        if (currentTime === undefined || isNaN(currentTime)) currentTime = 0;

        if (DOMElements.markInTimeDisplay) {
            DOMElements.markInTimeDisplay.textContent = state.currentMarkIn !== null ? formatTime(state.currentMarkIn, true) : formatTime(currentTime, true);
        }
        if (DOMElements.markOutTimeDisplay) {
            DOMElements.markOutTimeDisplay.textContent = state.currentMarkOut !== null ? formatTime(state.currentMarkOut, true) : formatTime(currentTime, true);
        }
        
        if (DOMElements.timelineMarkInOut && state.currentVideoDuration > 0) {
            if (state.currentMarkIn !== null && state.currentMarkOut !== null && state.currentMarkOut > state.currentMarkIn) {
                const inPercent = (state.currentMarkIn / state.currentVideoDuration) * 100;
                const outPercent = (state.currentMarkOut / state.currentVideoDuration) * 100;
                DOMElements.timelineMarkInOut.style.left = `${inPercent}%`;
                DOMElements.timelineMarkInOut.style.width = `${Math.max(0, outPercent - inPercent)}%`;
            } else if (state.currentMarkIn !== null) { 
                 const inPercent = (state.currentMarkIn / state.currentVideoDuration) * 100;
                 const currentPercent = (logVideoPlayer.currentTime / state.currentVideoDuration) * 100;
                 if (currentPercent > inPercent) {
                    DOMElements.timelineMarkInOut.style.left = `${inPercent}%`;
                    DOMElements.timelineMarkInOut.style.width = `${Math.max(0,currentPercent - inPercent)}%`;
                 } else {
                    DOMElements.timelineMarkInOut.style.width = '0%';    
                 }
            } else {
                DOMElements.timelineMarkInOut.style.width = '0%';
            }
        } else if (DOMElements.timelineMarkInOut) {
            DOMElements.timelineMarkInOut.style.width = '0%'; // Reset if no duration or no marks
        }
    }

    function handleMarkIn() {
        if (!logVideoPlayer) return;
        state.currentMarkIn = logVideoPlayer.currentTime;
        if (state.currentMarkOut !== null && state.currentMarkOut < state.currentMarkIn) {
            state.currentMarkOut = null; // Clear Mark Out if it's before new Mark In
        }
        updateMarkInOutDisplays();
        showNotification(`Mark In: ${formatTime(state.currentMarkIn, true)}`, "info", 1500);
    }

    function handleMarkOut() {
        if (!logVideoPlayer) return;
        state.currentMarkOut = logVideoPlayer.currentTime;
        if (state.currentMarkIn === null) {
             showNotification("Set Mark In first before Mark Out.", "error");
             state.currentMarkOut = null; // Reset Mark Out
             return;
        }
        if (state.currentMarkIn > state.currentMarkOut) {
            showNotification("Mark Out cannot be before Mark In. Adjusting Mark In.", "error");
            state.currentMarkIn = state.currentMarkOut; // Or, could choose to clear Mark In
        }
        updateMarkInOutDisplays();
        showNotification(`Mark Out: ${formatTime(state.currentMarkOut, true)}`, "info", 1500);
    }

    function handleTimelineClick(event) {
        if (!logVideoPlayer || isNaN(state.currentVideoDuration) || state.currentVideoDuration === 0 || !DOMElements.videoTimelineContainer) return;
        const timelineRect = DOMElements.videoTimelineContainer.getBoundingClientRect();
        const clickX = event.clientX - timelineRect.left;
        const clickPercent = Math.max(0, Math.min(1, clickX / timelineRect.width)); // Clamp between 0 and 1
        logVideoPlayer.currentTime = clickPercent * state.currentVideoDuration;
    }

    function handleStarRatingClick(event) {
        const star = event.target.closest('.star'); // Handle click on ☆ or ★
        if (star && star.dataset.value) {
            state.currentLogRating = parseInt(star.dataset.value);
            renderStarRatingForm();
        }
    }
    
    function renderStarRatingForm() {
        if (!DOMElements.logRating) return;
        const stars = DOMElements.logRating.querySelectorAll('.star');
        stars.forEach(star => {
            const starValue = parseInt(star.dataset.value);
            star.textContent = starValue <= state.currentLogRating ? '★' : '☆';
            star.classList.toggle('selected', starValue <= state.currentLogRating);
        });
    }

    function handleKeywordInputKeydown(event) {
        if (event.key === 'Enter' && DOMElements.logKeywordsInput && DOMElements.logKeywordsInput.value.trim() !== "") {
            event.preventDefault();
            const keyword = DOMElements.logKeywordsInput.value.trim().toLowerCase(); // Standardize to lowercase
            if (!currentLogKeywordsForm.includes(keyword)) {
                currentLogKeywordsForm.push(keyword);
                renderKeywordsForm();
            }
            DOMElements.logKeywordsInput.value = '';
        }
    }

    function renderKeywordsForm() {
        if (!DOMElements.logKeywordsContainer) return;
        DOMElements.logKeywordsContainer.innerHTML = '';
        currentLogKeywordsForm.forEach(keyword => {
            const tag = document.createElement('span');
            tag.className = 'keyword-tag';
            tag.textContent = sanitizeHTML(keyword);
            const removeBtn = document.createElement('span');
            removeBtn.className = 'remove-keyword';
            removeBtn.innerHTML = '×'; // Use HTML entity for 'x'
            removeBtn.onclick = () => {
                currentLogKeywordsForm = currentLogKeywordsForm.filter(k => k !== keyword);
                renderKeywordsForm();
            };
            tag.appendChild(removeBtn);
            DOMElements.logKeywordsContainer.appendChild(tag);
        });
    }

    async function handleSaveLog() {
        const notes = DOMElements.logNotes ? DOMElements.logNotes.value.trim() : "";
        if (state.currentMarkIn === null || state.currentMarkOut === null) {
            showNotification("Please set both Mark In and Mark Out points.", "error");
            return;
        }
        if (state.currentMarkIn >= state.currentMarkOut) {
            showNotification("Mark Out must be after Mark In.", "error");
            return;
        }
        if (!state.currentVideoId || !state.currentProjectId) {
            showNotification("Error: Missing video or project context for saving log.", "error");
            console.error("Missing video/project ID for log save:", state);
            return;
        }

        const logData = {
            videoId: state.currentVideoId,
            projectId: state.currentProjectId, // Important for global search/delete
            inTime: state.currentMarkIn,
            outTime: state.currentMarkOut,
            notes: notes,
            rating: state.currentLogRating,
            keywords: [...currentLogKeywordsForm], // clone
            createdAt: new Date().toISOString()
        };

        try {
            await dbAdd(STORE_LOGS, logData);
            showNotification("Log saved successfully.", "success");
            resetLogForm(); // This will also update displays
            loadLogsForCurrentVideo();
        } catch (error) {
            console.error("Error saving log:", error);
            showNotification(`Failed to save log. ${error.message}`, "error");
        }
    }

    function resetLogForm() {
        if (DOMElements.logNotes) DOMElements.logNotes.value = '';
        state.currentMarkIn = null;
        state.currentMarkOut = null;
        state.currentLogRating = 0;
        currentLogKeywordsForm = [];
        
        renderStarRatingForm(); // Updates star UI
        renderKeywordsForm(); // Clears keyword UI
        updateMarkInOutDisplays(); // Resets time displays and timeline marker
        
        if (DOMElements.timelineMarkInOut) {
            DOMElements.timelineMarkInOut.style.width = '0%';
            DOMElements.timelineMarkInOut.style.left = '0%';
        }
        if (DOMElements.logKeywordsInput) DOMElements.logKeywordsInput.value = ''; // Ensure input is cleared
    }

    async function loadLogsForCurrentVideo() {
        console.log("[LOGGING] Loading logs for video ID:", state.currentVideoId);
        if (!DOMElements.savedLogsList || !DOMElements.loggingStationEmptyState) {
            console.error("[LOGGING] Saved logs list or empty state DOM elements not found.");
            return;
        }
        try {
            const logs = await dbGetByIndex(STORE_LOGS, 'videoId', state.currentVideoId);
            logs.sort((a, b) => a.inTime - b.inTime); 

            DOMElements.savedLogsList.innerHTML = '';
            DOMElements.loggingStationEmptyState.classList.toggle('hidden', logs.length > 0);
            
            logs.forEach(log => {
                const item = document.createElement('div');
                item.className = 'log-item';
                item.innerHTML = `
                    <div class="log-item-header">
                        <span class="log-item-time">${formatTime(log.inTime)} - ${formatTime(log.outTime)}</span>
                        <span class="log-item-rating">${'★'.repeat(log.rating || 0)}${'☆'.repeat(5 - (log.rating || 0))}</span>
                    </div>
                    <p class="log-item-notes">${sanitizeHTML(log.notes) || "<em>No notes</em>"}</p>
                    <div class="log-item-keywords">
                        ${log.keywords && log.keywords.map(k => `<span class="keyword-tag">${sanitizeHTML(k)}</span>`).join('') || ''}
                    </div>
                    <div class="log-item-actions">
                        <button class="go-to-log-btn secondary" data-time="${log.inTime}">Go To</button>
                        <button class="delete-log-btn danger" data-log-id="${log.id}">Delete</button>
                    </div>
                `;
                item.querySelector('.go-to-log-btn').addEventListener('click', (e) => {
                    if (logVideoPlayer) {
                        logVideoPlayer.currentTime = parseFloat(e.target.dataset.time);
                        logVideoPlayer.play().catch(err => console.warn("Play interrupted or failed:", err)); // Handle play promise
                    }
                });
                item.querySelector('.delete-log-btn').addEventListener('click', (e) => handleDeleteLog(parseInt(e.target.dataset.logId)));
                DOMElements.savedLogsList.appendChild(item);
            });
            console.log("[LOGGING] Logs rendered.");
        } catch (error) {
            console.error("Error loading logs:", error);
            showNotification("Failed to load logs.", "error");
            DOMElements.savedLogsList.innerHTML = '<li>Error loading logs.</li>';
            DOMElements.loggingStationEmptyState.classList.add('hidden');
        }
    }
    
    async function handleDeleteLog(logId) {
        showConfirmDialog("Delete Log", "Are you sure you want to delete this log?", async (confirmed) => {
            if (confirmed) {
                try {
                    await dbDelete(STORE_LOGS, logId);
                    showNotification("Log deleted.", "success");
                    loadLogsForCurrentVideo(); 
                } catch (err) {
                    showNotification("Error deleting log.", "error");
                    console.error("Error deleting log", err);
                }
            }
        });
    }


    // --- Advanced Features ---
    let previewSelectsPlayer;
    let previewSelectsQueue = [];
    let currentPreviewSelectIndex = 0;
    let previewSelectTimeout = null; // To manage stopping at outTime

    async function handlePreviewSelects(videoId) {
        const videoData = await dbGetById(STORE_VIDEOS, videoId);
        if (!videoData || !videoData.fileObject) {
            showNotification("Video file not found for preview. Please re-add the video.", "error");
            console.error("Missing fileObject for preview, video ID:", videoId);
            return;
        }

        const logs = await dbGetByIndex(STORE_LOGS, 'videoId', videoId);
        if (logs.length === 0) {
            showNotification("No logs to preview for this video.", "info");
            return;
        }

        logs.sort((a,b) => a.inTime - b.inTime);
        previewSelectsQueue = logs;
        currentPreviewSelectIndex = 0;

        previewSelectsPlayer = DOMElements.previewSelectsPlayer;
        if (!previewSelectsPlayer || !DOMElements.previewSelectsModal || !DOMElements.previewSelectsInfo || !DOMElements.previewSelectsNotes) {
            console.error("Preview Selects modal UI elements missing.");
            showNotification("Cannot open preview: UI is missing.", "error");
            return;
        }

        if (previewSelectsPlayer.src && previewSelectsPlayer.src.startsWith('blob:')) {
             URL.revokeObjectURL(previewSelectsPlayer.src);
        }
        previewSelectsPlayer.src = URL.createObjectURL(videoData.fileObject);
        previewSelectsPlayer.onended = playNextSelectInQueue; // Use a renamed function
        // We'll use a timeout for stopping at outTime instead of ontimeupdate for more precise control
        previewSelectsPlayer.ontimeupdate = null; // Clear previous listener if any

        DOMElements.previewSelectsModal.classList.remove('hidden');
        playNextSelectInQueue(); 
    }

    function playNextSelectInQueue() {
        if (previewSelectTimeout) clearTimeout(previewSelectTimeout); // Clear any existing timeout

        if (currentPreviewSelectIndex >= previewSelectsQueue.length) {
            DOMElements.previewSelectsInfo.textContent = "All selects played.";
            DOMElements.previewSelectsNotes.textContent = "";
            previewSelectsPlayer.pause();
            return;
        }
        const currentSelect = previewSelectsQueue[currentPreviewSelectIndex];
        DOMElements.previewSelectsInfo.textContent = `Playing Select ${currentPreviewSelectIndex + 1} of ${previewSelectsQueue.length}`;
        DOMElements.previewSelectsNotes.textContent = sanitizeHTML(currentSelect.notes) || "No notes for this select.";
        
        previewSelectsPlayer.currentTime = currentSelect.inTime;
        previewSelectsPlayer.play().catch(err => console.warn("Preview play failed:", err));

        const durationOfSelect = (currentSelect.outTime - currentSelect.inTime) * 1000; // in ms
        previewSelectTimeout = setTimeout(() => {
            if (previewSelectsPlayer && !previewSelectsPlayer.paused) { // Check if still playing this select
                 previewSelectsPlayer.pause(); // Pause before moving to next
            }
            currentPreviewSelectIndex++;
            playNextSelectInQueue(); // This will play or end if queue is finished
        }, durationOfSelect > 0 ? durationOfSelect : 100); // Ensure a small delay even for zero-duration
    }

    function closePreviewSelectsModal() {
        if (previewSelectTimeout) clearTimeout(previewSelectTimeout);
        if (previewSelectsPlayer) {
            previewSelectsPlayer.pause();
            if (previewSelectsPlayer.src && previewSelectsPlayer.src.startsWith('blob:')) {
                 URL.revokeObjectURL(previewSelectsPlayer.src);
            }
            previewSelectsPlayer.src = ""; 
            previewSelectsPlayer.onended = null;
        }
        previewSelectsQueue = [];
        currentPreviewSelectIndex = 0;
        if (DOMElements.previewSelectsModal) DOMElements.previewSelectsModal.classList.add('hidden');
    }

    function handleKeyboardShortcuts(event) {
        if (state.currentScreen === 'logging-station') {
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT')) {
                return; // Don't interfere with text input
            }

            switch(event.key.toLowerCase()) {
                case ' ':
                    event.preventDefault();
                    if (logVideoPlayer) {
                        if (logVideoPlayer.paused) logVideoPlayer.play().catch(err => console.warn("Play failed:", err));
                        else logVideoPlayer.pause();
                    }
                    break;
                case 'i':
                    event.preventDefault();
                    handleMarkIn();
                    break;
                case 'o':
                    event.preventDefault();
                    handleMarkOut();
                    break;
                // Add more shortcuts if needed: JKL for rewind/pause/ff, arrow keys for seek
            }
        }
    }

    async function exportAllData() {
        showConfirmDialog(
            "Export Data",
            "This will export all projects, video metadata (not actual video files), and logs as a JSON file. Proceed?",
            async (confirmed) => {
                if (confirmed) {
                    try {
                        const projects = await dbGetAll(STORE_PROJECTS);
                        const videosFromDB = await dbGetAll(STORE_VIDEOS);
                        const logs = await dbGetAll(STORE_LOGS);

                        // Remove File objects before export
                        const videosForExport = videosFromDB.map(v => {
                            const { fileObject, ...videoMeta } = v; 
                            return videoMeta;
                        });

                        const dataToExport = {
                            exportFormatVersion: "1.0", // Good for future import/migration
                            exportDate: new Date().toISOString(),
                            projects,
                            videos: videosForExport,
                            logs
                        };

                        const jsonData = JSON.stringify(dataToExport, null, 2);
                        const blob = new Blob([jsonData], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `LogReel_Export_${new Date().toISOString().slice(0,10).replace(/-/g,'')}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        showNotification("Data exported successfully.", "success");
                    } catch (error) {
                        console.error("Error exporting data:", error);
                        showNotification("Failed to export data.", "error");
                    }
                }
            }
        );
    }


    // --- Initialization ---
    async function initApp() {
        console.log("[INITAPP] Initializing application...");
        // Cache DOM Elements - Crucial to do this early and correctly
        DOMElements.app = document.getElementById('app');
        DOMElements.projectDashboardScreen = document.getElementById('project-dashboard-screen');
        DOMElements.assemblyHubScreen = document.getElementById('assembly-hub-screen');
        DOMElements.loggingStationScreen = document.getElementById('logging-station-screen');
        
        DOMElements.createNewProjectBtn = document.getElementById('create-new-project-btn');
        DOMElements.projectList = document.getElementById('project-list');
        DOMElements.projectDashboardEmptyState = document.getElementById('project-dashboard-empty-state');
        DOMElements.exportAllDataBtn = document.getElementById('export-all-data-btn');

        DOMElements.assemblyBackToDashboardBtn = document.getElementById('assembly-back-to-dashboard-btn');
        DOMElements.assemblyProjectTitle = document.getElementById('assembly-project-title');
        DOMElements.assemblySearchBar = document.getElementById('assembly-search-bar');
        DOMElements.addVideosBtn = document.getElementById('add-videos-btn');
        DOMElements.videoFileInput = document.getElementById('video-file-input');
        DOMElements.videoList = document.getElementById('video-list');
        DOMElements.assemblyHubEmptyState = document.getElementById('assembly-hub-empty-state');

        DOMElements.loggingBackToAssemblyBtn = document.getElementById('logging-back-to-assembly-btn');
        DOMElements.loggingVideoFilename = document.getElementById('logging-video-filename');
        DOMElements.videoPlayer = document.getElementById('video-player');
        DOMElements.videoTimelineContainer = document.getElementById('video-timeline-container');
        DOMElements.timelineProgress = document.getElementById('timeline-progress');
        DOMElements.timelineMarkInOut = document.getElementById('timeline-mark-in-out');
        DOMElements.playbackSpeed = document.getElementById('playback-speed');
        DOMElements.markInBtn = document.getElementById('mark-in-btn');
        DOMElements.markOutBtn = document.getElementById('mark-out-btn');
        DOMElements.markInTimeDisplay = document.getElementById('mark-in-time-display');
        DOMElements.markOutTimeDisplay = document.getElementById('mark-out-time-display');
        DOMElements.logNotes = document.getElementById('log-notes');
        DOMElements.logRating = document.getElementById('log-rating');
        DOMElements.logKeywordsInput = document.getElementById('log-keywords-input');
        DOMElements.logKeywordsContainer = document.getElementById('log-keywords-container');
        DOMElements.saveLogBtn = document.getElementById('save-log-btn');
        DOMElements.savedLogsList = document.getElementById('saved-logs-list');
        DOMElements.loggingStationEmptyState = document.getElementById('logging-station-empty-state');

        DOMElements.previewSelectsModal = document.getElementById('preview-selects-modal');
        DOMElements.previewSelectsPlayer = document.getElementById('preview-selects-player');
        DOMElements.previewSelectsInfo = document.getElementById('preview-selects-info');
        DOMElements.previewSelectsNotes = document.getElementById('preview-selects-notes');
        
        DOMElements.confirmDialog = document.getElementById('confirm-dialog');
        DOMElements.confirmDialogTitle = document.getElementById('confirm-dialog-title');
        DOMElements.confirmDialogMessage = document.getElementById('confirm-dialog-message');
        DOMElements.confirmDialogCancelBtn = document.getElementById('confirm-dialog-cancel-btn');
        DOMElements.confirmDialogConfirmBtn = document.getElementById('confirm-dialog-confirm-btn');
        
        DOMElements.notificationsContainer = document.getElementById('notifications-container');

        // Verify all critical screen elements are cached
        if (!DOMElements.projectDashboardScreen || !DOMElements.assemblyHubScreen || !DOMElements.loggingStationScreen) {
            console.error("[INITAPP] CRITICAL ERROR: One or more main screen elements could not be found in the DOM. Halting initialization.");
            document.body.innerHTML = "<h1 style='color:red; text-align:center; padding-top: 20vh;'>Application UI Error: Core screen elements missing. Check console.</h1>";
            return;
        }
        console.log("[INITAPP] All DOMElements cached successfully.");


        // Init DB
        try {
            await initDB();
            // Moved "Application ready" to after initial navigation
        } catch (error) {
            showNotification("Failed to initialize database. App may not work correctly.", "error", 10000);
            console.error("[INITAPP] DB Init failed:", error);
            // Consider disabling features or showing a more permanent error message
        }

        // Setup Event Listeners (ensure elements exist before adding listeners)
        if (DOMElements.createNewProjectBtn) DOMElements.createNewProjectBtn.addEventListener('click', handleCreateNewProject);
        if (DOMElements.exportAllDataBtn) DOMElements.exportAllDataBtn.addEventListener('click', exportAllData);
        if (DOMElements.projectList) {
            DOMElements.projectList.addEventListener('click', (event) => {
                const deleteButton = event.target.closest('.delete-project-btn');
                if (deleteButton && deleteButton.dataset.projectId) {
                    handleDeleteProject(parseInt(deleteButton.dataset.projectId));
                }
                // Navigation to project handled in loadAndRenderProjects' item creation
            });
        }

        if (DOMElements.assemblyBackToDashboardBtn) DOMElements.assemblyBackToDashboardBtn.addEventListener('click', () => navigateTo('project-dashboard'));
        if (DOMElements.addVideosBtn) DOMElements.addVideosBtn.addEventListener('click', handleAddVideos);
        if (DOMElements.videoFileInput) {
            DOMElements.videoFileInput.addEventListener('change', (event) => {
                processSelectedVideoFiles(event.target.files);
                event.target.value = null; 
            });
        }
        if (DOMElements.assemblySearchBar) DOMElements.assemblySearchBar.addEventListener('input', handleAssemblySearch);


        if (DOMElements.loggingBackToAssemblyBtn) {
            DOMElements.loggingBackToAssemblyBtn.addEventListener('click', () => {
                if (logVideoPlayer) {
                    logVideoPlayer.pause();
                    if (logVideoPlayer.src && logVideoPlayer.src.startsWith('blob:')) {
                        URL.revokeObjectURL(logVideoPlayer.src);
                    }
                    logVideoPlayer.src = ""; 
                    logVideoPlayer.onloadedmetadata = null;
                    logVideoPlayer.ontimeupdate = null;
                    logVideoPlayer.onseeked = null;
                }
                navigateTo('assembly-hub', { projectId: state.currentProjectId, projectName: state.currentProjectName });
            });
        }
        if (DOMElements.markInBtn) DOMElements.markInBtn.addEventListener('click', handleMarkIn);
        if (DOMElements.markOutBtn) DOMElements.markOutBtn.addEventListener('click', handleMarkOut);
        if (DOMElements.videoTimelineContainer) DOMElements.videoTimelineContainer.addEventListener('click', handleTimelineClick);
        if (DOMElements.logRating) DOMElements.logRating.addEventListener('click', handleStarRatingClick);
        if (DOMElements.logKeywordsInput) DOMElements.logKeywordsInput.addEventListener('keydown', handleKeywordInputKeydown);
        if (DOMElements.saveLogBtn) DOMElements.saveLogBtn.addEventListener('click', handleSaveLog);
        if (DOMElements.playbackSpeed) {
            DOMElements.playbackSpeed.addEventListener('change', (e) => {
                if(logVideoPlayer) logVideoPlayer.playbackRate = parseFloat(e.target.value);
            });
        }

        document.querySelectorAll('.close-modal-btn').forEach(btn => {
            btn.addEventListener('click', (event) => {
                const modalId = event.target.dataset.targetModal;
                if (modalId === 'preview-selects-modal') {
                    closePreviewSelectsModal();
                } else if (modalId && document.getElementById(modalId)) { // Check if modalId is valid
                    document.getElementById(modalId).classList.add('hidden');
                } else if (event.target.closest('.modal')) { // Fallback for any close btn inside a modal
                     event.target.closest('.modal').classList.add('hidden');
                }
            });
        });
        if (DOMElements.confirmDialogCancelBtn) DOMElements.confirmDialogCancelBtn.addEventListener('click', () => {
            if (DOMElements.confirmDialog) DOMElements.confirmDialog.classList.add('hidden');
        });


        document.addEventListener('keydown', handleKeyboardShortcuts);
        
        // Initial Render
        console.log("[INITAPP] Navigating to initial screen: project-dashboard");
        navigateTo('project-dashboard');
        showNotification("Application ready.", "success", 2000); // Show after initial screen is supposed to be visible
        console.log("[INITAPP] Application initialization complete.");
    }

    // Start the application
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initApp);
    } else {
        // DOMContentLoaded has already fired
        initApp();
    }

})();
</script>
</body>
</html>
